{"version":3,"file":"TableColumnSchemaEditor.stories-6d3ae1d6.js","sources":["../../../../node_modules/.pnpm/@mui+icons-material@5.14.16_@mui+material@5.14.17_@types+react@18.0.27_react@18.2.0/node_modules/@mui/icons-material/esm/DownloadTwoTone.js","../../../../node_modules/.pnpm/@mui+icons-material@5.14.16_@mui+material@5.14.17_@types+react@18.0.27_react@18.2.0/node_modules/@mui/icons-material/esm/North.js","../../../../node_modules/.pnpm/@mui+icons-material@5.14.16_@mui+material@5.14.17_@types+react@18.0.27_react@18.2.0/node_modules/@mui/icons-material/esm/South.js","../../../../node_modules/.pnpm/jotai@2.4.2_@types+react@18.0.27_react@18.2.0/node_modules/jotai/esm/vanilla/utils.mjs","../../../../node_modules/.pnpm/jotai@2.4.2_@types+react@18.0.27_react@18.2.0/node_modules/jotai/esm/react/utils.mjs","../../src/components/TableColumnSchemaEditor/TableColumnSchemaEditorUtils.ts","../../src/components/TableColumnSchemaEditor/TableColumnSchemaFormReducer.ts","../../src/components/TableColumnSchemaEditor/ColumnModelForm.tsx","../../src/synapse-queries/table/useColumnModel.ts","../../src/components/TableColumnSchemaEditor/ImportTableColumnsButton.tsx","../../src/components/TableColumnSchemaEditor/TableColumnSchemaForm.tsx","../../src/components/TableColumnSchemaEditor/TableColumnSchemaEditor.tsx"],"sourcesContent":["\"use client\";\n\nimport createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon([/*#__PURE__*/_jsx(\"path\", {\n  d: \"M13 9V5h-2v6H9.83L12 13.17 14.17 11H13z\",\n  opacity: \".3\"\n}, \"0\"), /*#__PURE__*/_jsx(\"path\", {\n  d: \"M15 9V3H9v6H5l7 7 7-7h-4zm-3 4.17L9.83 11H11V5h2v6h1.17L12 13.17zM5 18h14v2H5z\"\n}, \"1\")], 'DownloadTwoTone');","\"use client\";\n\nimport createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"m5 9 1.41 1.41L11 5.83V22h2V5.83l4.59 4.59L19 9l-7-7-7 7z\"\n}), 'North');","\"use client\";\n\nimport createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"m19 15-1.41-1.41L13 18.17V2h-2v16.17l-4.59-4.59L5 15l7 7 7-7z\"\n}), 'South');","import { atom } from 'jotai/vanilla';\n\nconst RESET = Symbol();\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, action) => set(anAtom, reducer(get(anAtom), action))\n  );\n  return anAtom;\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove)\n      return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$4 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$4, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = atom((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        if (value instanceof Promise || prev instanceof Promise) {\n          return Promise.all([value, prev]).then(selectValue);\n        }\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo1$1 = (create, dep1) => (cache1$3.has(dep1) ? cache1$3 : cache1$3.set(dep1, create())).get(dep1);\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null)\n    return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  return memo1$1(() => {\n    const frozenAtom = atom(\n      (get) => deepFreeze(get(anAtom)),\n      (_get, set, arg) => set(anAtom, arg)\n    );\n    return frozenAtom;\n  }, anAtom);\n}\nfunction freezeAtomCreator(createAtom) {\n  return (...params) => {\n    const anAtom = createAtom(...params);\n    const origRead = anAtom.read;\n    anAtom.read = (get, options) => deepFreeze(origRead(get, options));\n    return anAtom;\n  };\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = atom((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? atom(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : atom((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        set(overwrittenAtom, EMPTY);\n      } else if (typeof update === \"function\") {\n        const prevValue = get(anAtom);\n        set(overwrittenAtom, update(prevValue));\n      } else {\n        set(overwrittenAtom, update);\n      }\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction createJSONStorage(getStringStorage) {\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2);\n          } catch {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a = getStringStorage()) == null ? void 0 : _a.getItem(key)) != null ? _b : null;\n      if (isPromiseLike(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.setItem(key, JSON.stringify(newValue));\n    },\n    removeItem: (key) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.removeItem(key);\n    }\n  };\n  if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    storage.subscribe = (key, callback, initialValue) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          let newValue;\n          try {\n            newValue = JSON.parse(e.newValue || \"\");\n          } catch {\n            newValue = initialValue;\n          }\n          callback(newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage(\n  () => typeof window !== \"undefined\" ? window.localStorage : void 0\n);\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, unstable_options) {\n  const getOnInit = unstable_options == null ? void 0 : unstable_options.unstable_getOnInit;\n  const baseAtom = atom(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    if (!getOnInit) {\n      setAtom(storage.getItem(key, initialValue));\n    }\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (nextValue instanceof Promise) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (result instanceof Promise) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!(value instanceof Promise)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached = loadableCache.get(promise);\n        if (cached) {\n          return cached;\n        }\n        loadableCache.set(promise, LOADING);\n        promise.then(\n          (data) => {\n            loadableCache.set(promise, { state: \"hasData\", data });\n          },\n          (error) => {\n            loadableCache.set(promise, { state: \"hasError\", error });\n          }\n        ).finally(setSelf);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = atom(0);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = atom(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!(promise instanceof Promise)) {\n            return { v: promise };\n          }\n          if (promise === (prev == null ? void 0 : prev.p)) {\n            if (promiseErrorCache.has(promise)) {\n              throw promiseErrorCache.get(promise);\n            }\n            if (promiseResultCache.has(promise)) {\n              return {\n                p: promise,\n                v: promiseResultCache.get(promise)\n              };\n            }\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            promise.then(\n              (v) => promiseResultCache.set(promise, v),\n              (e) => promiseErrorCache.set(promise, e)\n            ).finally(setSelf);\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v) };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return atom(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"v\" in state) {\n            return state.v;\n          }\n          return state.f;\n        },\n        anAtom.write\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithObservable, atomWithReducer, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, unwrap };\n","import { useCallback, useMemo } from 'react';\nimport { useSetAtom, useAtom, useStore } from 'jotai/react';\nimport { RESET } from 'jotai/vanilla/utils';\nimport { atom } from 'jotai/vanilla';\n\nfunction useResetAtom(anAtom, options) {\n  const setAtom = useSetAtom(anAtom, options);\n  const resetAtom = useCallback(() => setAtom(RESET), [setAtom]);\n  return resetAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, options) {\n  const [state, setState] = useAtom(anAtom, options);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction useAtomCallback(callback, options) {\n  const anAtom = useMemo(\n    () => atom(null, (get, set, ...args) => callback(get, set, ...args)),\n    [callback]\n  );\n  return useSetAtom(anAtom, options);\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, options) {\n  const store = useStore(options);\n  const hydratedSet = getHydratedSet(store);\n  for (const [atom, value] of values) {\n    if (!hydratedSet.has(atom) || (options == null ? void 0 : options.dangerouslyForceHydrate)) {\n      hydratedSet.add(atom);\n      store.set(atom, value);\n    }\n  }\n}\nconst getHydratedSet = (store) => {\n  let hydratedSet = hydratedMap.get(store);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(store, hydratedSet);\n  }\n  return hydratedSet;\n};\n\nexport { useAtomCallback, useHydrateAtoms, useReducerAtom, useResetAtom };\n","import {\n  ColumnModel,\n  ColumnType,\n  ColumnTypeEnum,\n  Entity,\n  ENTITY_VIEW_TYPE_MASK_DATASET,\n  ENTITY_VIEW_TYPE_MASK_FILE,\n  FacetType,\n  JsonSubColumnModel,\n  ViewEntityType,\n  ViewScope,\n} from '@sage-bionetworks/synapse-types'\nimport { SetOptional } from 'type-fest'\nimport {\n  ColumnModelFormData,\n  JsonSubColumnModelFormData,\n} from './TableColumnSchemaFormReducer'\nimport {\n  convertToEntityType,\n  isDataset,\n  isDatasetCollection,\n  isEntityView,\n  isSubmissionView,\n} from '../../utils/functions/EntityTypeUtils'\n\n/**\n * These column types can only be used in Tables. They can not be used in views.\n *  See SWC-6333 - for views, only allow column types that are mapped to annotation types.\n */\nconst unsupportedTypesForViews = [\n  ColumnTypeEnum.LARGETEXT,\n  ColumnTypeEnum.MEDIUMTEXT,\n  ColumnTypeEnum.JSON,\n]\nexport function getAllowedColumnTypes(\n  isView: boolean,\n  isJsonSubColumnFacet: boolean,\n): ColumnTypeEnum[] {\n  return Object.values(ColumnTypeEnum)\n    .filter(columnType =>\n      isView ? !unsupportedTypesForViews.includes(columnType) : true,\n    )\n    .filter(columnType => {\n      if (isJsonSubColumnFacet) {\n        switch (columnType) {\n          // JSON Subcolumns cannot be JSON or LIST types\n          case ColumnTypeEnum.JSON:\n          case ColumnTypeEnum.STRING_LIST:\n          case ColumnTypeEnum.INTEGER_LIST:\n          case ColumnTypeEnum.BOOLEAN_LIST:\n          case ColumnTypeEnum.DATE_LIST:\n          case ColumnTypeEnum.USERID_LIST:\n          case ColumnTypeEnum.ENTITYID_LIST:\n            return false\n          default:\n            return true\n        }\n      }\n      return true\n    })\n}\n\nexport function getFacetTypeFriendlyName(facetType: FacetType) {\n  switch (facetType) {\n    case 'enumeration':\n      return 'Values'\n    case 'range':\n      return 'Range'\n    default:\n      return facetType\n  }\n}\nexport function getColumnTypeFriendlyName(type: ColumnType | ColumnTypeEnum) {\n  switch (type) {\n    case ColumnTypeEnum.STRING:\n      return 'String'\n    case ColumnTypeEnum.DOUBLE:\n      return 'Double'\n    case ColumnTypeEnum.BOOLEAN:\n      return 'Boolean'\n    case ColumnTypeEnum.INTEGER:\n      return 'Integer'\n    case ColumnTypeEnum.DATE:\n      return 'Date'\n    case ColumnTypeEnum.FILEHANDLEID:\n      return 'File'\n    case ColumnTypeEnum.ENTITYID:\n      return 'Entity'\n    case ColumnTypeEnum.LINK:\n      return 'Link'\n    case ColumnTypeEnum.MEDIUMTEXT:\n      return 'MediumText'\n    case ColumnTypeEnum.LARGETEXT:\n      return 'LargeText'\n    case ColumnTypeEnum.USERID:\n      return 'User'\n    case ColumnTypeEnum.STRING_LIST:\n      return 'String List'\n    case ColumnTypeEnum.INTEGER_LIST:\n      return 'Integer List'\n    case ColumnTypeEnum.BOOLEAN_LIST:\n      return 'Boolean List'\n    case ColumnTypeEnum.DATE_LIST:\n      return 'Date List'\n    case ColumnTypeEnum.USERID_LIST:\n      return 'User ID List'\n    case ColumnTypeEnum.ENTITYID_LIST:\n      return 'Entity ID List'\n    case ColumnTypeEnum.EVALUATIONID:\n      return 'Evaluation'\n    case ColumnTypeEnum.SUBMISSIONID:\n      return 'Submission'\n    case ColumnTypeEnum.JSON:\n      return 'JSON'\n    default:\n      return type\n  }\n}\n\n/**\n * Can the given type have a size?\n *\n * @param type\n * @return\n */\nexport function canHaveSize(type: ColumnType | ColumnTypeEnum): boolean {\n  switch (type) {\n    case ColumnTypeEnum.STRING:\n    case ColumnTypeEnum.STRING_LIST:\n    case ColumnTypeEnum.LINK:\n      return true\n    default:\n      // all others are false\n      return false\n  }\n}\n\nexport function canHaveMaxListLength(\n  type: ColumnType | ColumnTypeEnum,\n): boolean {\n  switch (type) {\n    case ColumnTypeEnum.STRING_LIST:\n    case ColumnTypeEnum.BOOLEAN_LIST:\n    case ColumnTypeEnum.DATE_LIST:\n    case ColumnTypeEnum.INTEGER_LIST:\n      return true\n    default:\n      // all others are false\n      return false\n  }\n}\n\n/**\n * Configure the facet selection based on the column type\n *\n * @param type a ColumnType for which to get the facet selection\n * @param isJsonSubColumnFacet is this a facet for a json subcolumn?\n * @return the allowed facetTypes, or null if faceting is not allowed\n */\nexport function configureFacetsForType(\n  type: ColumnType | ColumnTypeEnum,\n  isJsonSubColumnFacet: boolean,\n): (FacetType | undefined)[] | null {\n  let allowedFacetTypes: (FacetType | undefined)[] | null\n  switch (type) {\n    case ColumnTypeEnum.INTEGER:\n    case ColumnTypeEnum.INTEGER_LIST:\n      allowedFacetTypes = ['enumeration', 'range']\n      break\n    case ColumnTypeEnum.STRING:\n    case ColumnTypeEnum.BOOLEAN:\n    case ColumnTypeEnum.USERID:\n    case ColumnTypeEnum.ENTITYID:\n    case ColumnTypeEnum.STRING_LIST:\n    case ColumnTypeEnum.BOOLEAN_LIST:\n    case ColumnTypeEnum.ENTITYID_LIST:\n    case ColumnTypeEnum.USERID_LIST:\n    case ColumnTypeEnum.EVALUATIONID:\n      allowedFacetTypes = ['enumeration']\n      break\n    case ColumnTypeEnum.DOUBLE:\n    case ColumnTypeEnum.DATE:\n    case ColumnTypeEnum.DATE_LIST:\n      allowedFacetTypes = ['range']\n      break\n    default:\n      allowedFacetTypes = null\n  }\n\n  if (allowedFacetTypes && !isJsonSubColumnFacet) {\n    // jsonSubColumn facets MUST have a facet definition, but regular column models do not need one\n    // So allow `undefined` for regular columnModels.\n    allowedFacetTypes = [undefined, ...allowedFacetTypes]\n  }\n  return allowedFacetTypes\n}\n\nexport function canHaveDefault(\n  type: ColumnType | ColumnTypeEnum,\n  isView: boolean,\n  isJsonSubColumnFacet: boolean,\n) {\n  // SWC-6333: default types are not allowed in views\n  if (!isView && !isJsonSubColumnFacet) {\n    switch (type) {\n      case ColumnTypeEnum.ENTITYID:\n      case ColumnTypeEnum.FILEHANDLEID:\n      case ColumnTypeEnum.USERID:\n      case ColumnTypeEnum.MEDIUMTEXT:\n      case ColumnTypeEnum.LARGETEXT:\n      case ColumnTypeEnum.JSON:\n        return false\n      default:\n        return true\n    }\n  } else {\n    return false\n  }\n}\n\nconst DEFAULT_STRING_SIZE = 50\nconst MAX_STRING_SIZE = 1000\n\n/**\n * Get the default max size for a given type.\n *\n * @param type\n * @return\n */\nexport function getMaxSizeForType(type: ColumnType | ColumnTypeEnum): number {\n  switch (type) {\n    case ColumnTypeEnum.STRING:\n    case ColumnTypeEnum.STRING_LIST:\n      return DEFAULT_STRING_SIZE\n    case ColumnTypeEnum.LINK:\n      return MAX_STRING_SIZE\n    default:\n      throw new Error(`Type is not known to have a max size: ${type}`)\n  }\n}\n\nexport function canHaveRestrictedValues(\n  type: ColumnType | ColumnTypeEnum,\n  isJsonSubColumnFacet: boolean,\n): boolean {\n  if (isJsonSubColumnFacet) {\n    return false\n  }\n  switch (type) {\n    case ColumnTypeEnum.STRING:\n    case ColumnTypeEnum.INTEGER:\n    case ColumnTypeEnum.ENTITYID:\n      return true\n    default:\n      // all other are false\n      return false\n  }\n}\n\n/**\n * Transform the form data for the TableColumnSchemaForm to ColumnModels to be sent to Synapse\n * @param formData the form data to transform\n */\nexport function transformFormDataToColumnModels(\n  formData: ColumnModelFormData[],\n): SetOptional<ColumnModel, 'id'>[] {\n  return formData.map(\n    (formEntry: ColumnModelFormData): SetOptional<ColumnModel, 'id'> => {\n      // Remove the isSelected and isOriginallyDefaultColumn fields because these were only used for the UI.\n      const { isSelected, isOriginallyDefaultColumn, ...rest } = formEntry\n      const columnModel = rest as SetOptional<ColumnModel, 'id'>\n      if (columnModel.jsonSubColumns) {\n        columnModel.jsonSubColumns = (\n          columnModel.jsonSubColumns as JsonSubColumnModelFormData[]\n        ).map(\n          (\n            jsonSubColumnFormData: JsonSubColumnModelFormData,\n          ): JsonSubColumnModel => {\n            // isSelected field from the subcolumn for the same reason\n            const { isSelected, ...rest } = jsonSubColumnFormData\n            return {\n              ...rest,\n            }\n          },\n        )\n      }\n      return columnModel\n    },\n  )\n}\n\n/**\n * Transform ColumnModels returned by Synapse into the form data for the TableColumnSchemaForm.\n * Default column models, if available, are used to determine which columns should not be editable in the form.\n * @param columnModels\n * @param defaultColumns\n */\nexport function transformColumnModelsToFormData(\n  columnModels: SetOptional<ColumnModel, 'id'>[],\n  defaultColumns: ColumnModel[] = [],\n): ColumnModelFormData[] {\n  return columnModels.map((cm): ColumnModelFormData => {\n    return {\n      ...cm,\n      isSelected: false,\n      // If the name matches a known default column model, then we consider it to be a default column model itself\n      isOriginallyDefaultColumn: defaultColumns.some(\n        dcm => dcm.name === cm.name,\n      ),\n      jsonSubColumns: cm.jsonSubColumns\n        ? cm.jsonSubColumns.map(jsc => ({\n            ...jsc,\n            isSelected: false,\n          }))\n        : undefined,\n    }\n  })\n}\n\nexport function getViewScopeForEntity(entity: Entity): ViewScope | undefined {\n  if (isEntityView(entity)) {\n    return {\n      scope: entity.scopeIds,\n      viewTypeMask: entity.viewTypeMask,\n      viewEntityType: convertToEntityType(\n        entity.concreteType,\n      ) as ViewEntityType,\n    }\n  } else if (isDataset(entity) || isDatasetCollection(entity)) {\n    const mask = isDataset(entity)\n      ? ENTITY_VIEW_TYPE_MASK_FILE\n      : ENTITY_VIEW_TYPE_MASK_DATASET\n    return {\n      scope: (entity.items ?? []).map(\n        item => `${item.entityId}.${item.versionNumber}`,\n      ),\n      viewTypeMask: mask,\n      viewEntityType: convertToEntityType(\n        entity.concreteType,\n      ) as ViewEntityType,\n    }\n  } else if (isSubmissionView(entity)) {\n    return {\n      scope: entity.scopeIds,\n      viewTypeMask: undefined,\n      viewEntityType: convertToEntityType(\n        entity.concreteType,\n      ) as ViewEntityType,\n    }\n  }\n  return undefined\n}\n","import {\n  ColumnModel,\n  ColumnTypeEnum,\n  JsonSubColumnModel,\n} from '@sage-bionetworks/synapse-types'\nimport { atomWithReducer } from 'jotai/utils'\nimport { SetOptional } from 'type-fest'\nimport { cloneDeep } from 'lodash-es'\nimport {\n  canHaveMaxListLength,\n  canHaveRestrictedValues,\n  canHaveSize,\n  configureFacetsForType,\n} from './TableColumnSchemaEditorUtils'\n\nexport function getIsAllSelected(formData: ColumnModelFormData[]) {\n  return (\n    formData.length > 0 &&\n    formData.every(\n      cm =>\n        // Is selected\n        cm.isSelected &&\n        // And all subcolumns are selected (true if there are no subcolumns)\n        (cm.jsonSubColumns ?? []).every(\n          (jsc: JsonSubColumnModelFormData) => jsc.isSelected,\n        ),\n    )\n  )\n}\n\nexport function getNumberOfSelectedItems(formData: ColumnModelFormData[]) {\n  return formData.reduce((acc, curr) => {\n    if (curr.isSelected) {\n      acc += 1\n    }\n    if (curr.jsonSubColumns) {\n      curr.jsonSubColumns.forEach((jsc: JsonSubColumnModelFormData) => {\n        if (jsc.isSelected) {\n          acc += 1\n        }\n      })\n    }\n    return acc\n  }, 0)\n}\n\nexport function getDefaultColumnModelFormData(): ColumnModelFormData {\n  return {\n    name: '',\n    columnType: ColumnTypeEnum.STRING,\n    isOriginallyDefaultColumn: false,\n    isSelected: false,\n  }\n}\n\nexport function getDefaultJsonSubColumnFormData(): JsonSubColumnModelFormData {\n  return {\n    name: '',\n    jsonPath: '',\n    columnType: ColumnTypeEnum.STRING,\n    facetType: 'enumeration',\n    isSelected: false,\n  }\n}\n\n/**\n * In the provided array, move items up where the predicate evaluates to true\n * @param arr the array to reorder\n * @param predicate a function that returns true if the item should be moved up\n * @returns - a new array with the reordered items\n */\nfunction moveSelectedItemsUp<T = unknown>(\n  arr: T[],\n  predicate: (item: T) => boolean,\n) {\n  const newArr = [...arr]\n  newArr.forEach((item, index) => {\n    // For each item that should move up, swap it with the previous item\n    if (\n      // Cannot move index 0 up\n      index > 0 &&\n      // Only move if the predicate matches\n      predicate(item) &&\n      // If the previous item should also move, skip the swap\n      !predicate(newArr[index - 1])\n    ) {\n      // swap the items\n      const temp = newArr[index - 1]\n      newArr[index - 1] = newArr[index]\n      newArr[index] = temp\n    }\n  })\n  return newArr\n}\n\n/**\n * In the provided array, move items down where the predicate evaluates to true\n * @param arr the array to reorder\n * @param predicate a function that returns true if the item should be moved down\n * @returns - a new array with the reordered items\n */\nfunction moveSelectedItemsDown<T = unknown>(\n  arr: T[],\n  predicate: (item: T) => boolean,\n) {\n  const newArr = [...arr]\n  // Start from the end and work backwards, otherwise items could be moved more than once\n  for (let i = newArr.length - 1; i >= 0; i--) {\n    const item = newArr[i]\n    if (\n      // Cannot move the last item down\n      i < newArr.length - 1 &&\n      // Only move if the predicate matches\n      predicate(item) &&\n      // If the next item should also be moved, don't swap\n      !predicate(newArr[i + 1])\n    ) {\n      // swap the items\n      const temp = newArr[i]\n      newArr[i] = newArr[i + 1]\n      newArr[i + 1] = temp\n    }\n  }\n  return newArr\n}\n\nexport type JsonSubColumnModelFormData = JsonSubColumnModel & {\n  // add `isSelected` to the data object\n  isSelected: boolean\n}\n\nexport type ColumnModelFormData = Omit<\n  SetOptional<ColumnModel, 'id'>,\n  'jsonSubColumns'\n> & {\n  // add `isSelected` to the data object\n  isSelected: boolean\n  // If the column originates as a default column based on column name, fields other than the facet type are readonly\n  // This field should not be automatically updated, because new columns with the same name should not immediately become readonly.\n  isOriginallyDefaultColumn: boolean\n  // jsonSubColumns will also include formData (like isSelected)\n  jsonSubColumns?: JsonSubColumnModelFormData[]\n}\n\ntype TableColumnSchemaFormReducerAction =\n  | {\n      type: 'setValue'\n      value: ColumnModelFormData[]\n    }\n  | {\n      type: 'toggleSelect'\n      columnModelIndex: number\n      jsonSubColumnModelIndex?: number\n    }\n  | { type: 'toggleSelectAll' }\n  | {\n      type: 'appendColumn'\n    }\n  | {\n      type: 'appendJsonSubColumn'\n      columnModelIndex: number\n    }\n  | {\n      type: 'setColumnModelValue'\n      columnModelIndex: number\n      jsonSubColumnModelIndex?: number\n      value: ColumnModelFormData | JsonSubColumnModelFormData\n    }\n  | {\n      type: 'changeColumnModelType'\n      newColumnType: ColumnTypeEnum\n      columnModelIndex: number\n      jsonSubColumnModelIndex?: number\n    }\n  | {\n      type: 'move'\n      from: {\n        columnModelIndex: number\n        jsonSubColumnModelIndex?: number\n      }\n      to: { columnModelIndex: number; jsonSubColumnModelIndex?: number }\n    }\n  | {\n      type: 'moveUp'\n    }\n  | {\n      type: 'moveDown'\n    }\n  | {\n      type: 'delete'\n    }\n\nfunction changeColumnModelType(\n  action: {\n    type: 'changeColumnModelType'\n    newColumnType: ColumnTypeEnum\n    columnModelIndex: number\n    jsonSubColumnModelIndex?: number\n  },\n  prevState: ColumnModelFormData[],\n) {\n  const { columnModelIndex, jsonSubColumnModelIndex, newColumnType } = action\n  let newColumnModelValue: ColumnModelFormData | JsonSubColumnModelFormData\n\n  // Create a copy of the selected column model\n  if (prevState && prevState[columnModelIndex]) {\n    if (\n      prevState[columnModelIndex].jsonSubColumns &&\n      jsonSubColumnModelIndex !== undefined\n    ) {\n      newColumnModelValue = cloneDeep(\n        prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex],\n      )\n    } else {\n      newColumnModelValue = cloneDeep(prevState[columnModelIndex])\n    }\n  } else {\n    throw new Error(\n      'Cannot change column model type for a column that does not exist',\n    )\n  }\n\n  // Update the column model. Remove fields that no longer make sense for the new column type\n  newColumnModelValue.columnType = newColumnType\n  if (!canHaveSize(newColumnType) && 'maximumSize' in newColumnModelValue) {\n    delete newColumnModelValue.maximumSize\n  }\n  if (\n    !canHaveMaxListLength(newColumnType) &&\n    'maximumListLength' in newColumnModelValue\n  ) {\n    delete newColumnModelValue.maximumListLength\n  }\n  if (\n    !canHaveRestrictedValues(newColumnType, !!jsonSubColumnModelIndex) &&\n    'enumValues' in newColumnModelValue\n  ) {\n    delete newColumnModelValue.enumValues\n  }\n\n  const allowedFacetTypes = configureFacetsForType(\n    newColumnType,\n    !!jsonSubColumnModelIndex,\n  )\n  if (\n    'facetType' in newColumnModelValue &&\n    (allowedFacetTypes === null ||\n      !allowedFacetTypes.includes(newColumnModelValue.facetType))\n  ) {\n    delete newColumnModelValue.facetType\n  }\n\n  if (\n    'jsonSubColumns' in newColumnModelValue &&\n    newColumnType !== ColumnTypeEnum.JSON\n  ) {\n    delete newColumnModelValue.jsonSubColumns\n  }\n\n  // Replace the value\n  if (prevState && prevState[columnModelIndex]) {\n    if (\n      prevState[columnModelIndex].jsonSubColumns &&\n      jsonSubColumnModelIndex !== undefined\n    ) {\n      prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex] =\n        newColumnModelValue as JsonSubColumnModelFormData\n    } else {\n      prevState[columnModelIndex] = newColumnModelValue as ColumnModelFormData\n    }\n  }\n}\n\nfunction toggleSelectAll(prevState: ColumnModelFormData[]) {\n  const allSelected = getIsAllSelected(prevState)\n  if (allSelected) {\n    return prevState.map(cm => ({\n      ...cm,\n      jsonSubColumns: cm.jsonSubColumns?.map(jsc => ({\n        ...jsc,\n        isSelected: false,\n      })),\n      isSelected: false,\n    }))\n  } else {\n    return prevState.map(cm => ({\n      ...cm,\n      jsonSubColumns: cm.jsonSubColumns?.map(jsc => ({\n        ...jsc,\n        isSelected: true,\n      })),\n      isSelected: true,\n    }))\n  }\n}\n\nfunction setColumnModelValue(\n  action: {\n    type: 'setColumnModelValue'\n    columnModelIndex: number\n    jsonSubColumnModelIndex?: number\n    value: ColumnModelFormData | JsonSubColumnModelFormData\n  },\n  prevState: ColumnModelFormData[],\n) {\n  const { columnModelIndex, jsonSubColumnModelIndex, value } = action\n  if (prevState && prevState[columnModelIndex]) {\n    if (\n      prevState[columnModelIndex].jsonSubColumns &&\n      jsonSubColumnModelIndex !== undefined\n    ) {\n      prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex] =\n        value as JsonSubColumnModelFormData\n    } else {\n      prevState[columnModelIndex] = value as ColumnModelFormData\n    }\n  }\n}\n\nfunction toggleSelect(\n  action: {\n    type: 'toggleSelect'\n    columnModelIndex: number\n    jsonSubColumnModelIndex?: number\n  },\n  prevState: ColumnModelFormData[],\n) {\n  const { columnModelIndex, jsonSubColumnModelIndex } = action\n  if (prevState && prevState[columnModelIndex]) {\n    if (\n      prevState[columnModelIndex].jsonSubColumns &&\n      jsonSubColumnModelIndex !== undefined\n    ) {\n      const cm =\n        prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex]\n      prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex] = {\n        ...cm,\n        isSelected: !cm.isSelected,\n      }\n    } else {\n      const cm = prevState[columnModelIndex]\n      prevState[columnModelIndex] = { ...cm, isSelected: !cm.isSelected }\n    }\n  }\n}\n\nfunction deleteColumnModel(prevState: ColumnModelFormData[]) {\n  return prevState\n    .filter(cm => !cm.isSelected)\n    .map(cm => {\n      if (cm.jsonSubColumns) {\n        cm = {\n          ...cm,\n          jsonSubColumns: cm.jsonSubColumns.filter(\n            (jsc: JsonSubColumnModelFormData) => !jsc.isSelected,\n          ),\n        }\n      }\n      return cm\n    })\n}\n\n/**\n * Returns a new, shallowly-cloned array that moves the object from the `fromIndex` to the `toIndex`.\n * Derived from https://stackoverflow.com/a/6470794/9723359\n *\n * Returns the same array if the `fromIndex` and `toIndex` are the same.\n * @param arrayToReorder\n * @param fromIndex\n * @param toIndex\n */\nfunction moveElementInArray<T = unknown>(\n  arrayToReorder: Array<T>,\n  fromIndex: number,\n  toIndex: number,\n): Array<T> {\n  if (fromIndex == toIndex) {\n    return arrayToReorder\n  }\n  const newArray = [...arrayToReorder]\n  const elementToMove = newArray[fromIndex]\n  newArray.splice(fromIndex, 1)\n  newArray.splice(toIndex, 0, elementToMove)\n  return newArray\n}\n\n/**\n * Moves a column model or jsonSubColumn from the `from` index to the `to` index\n * @param action\n * @param prevState\n */\nfunction moveColumnModel(\n  action: {\n    type: 'move'\n    from: { columnModelIndex: number; jsonSubColumnModelIndex?: number }\n    to: { columnModelIndex: number; jsonSubColumnModelIndex?: number }\n  },\n  prevState: ColumnModelFormData[],\n): ColumnModelFormData[] {\n  const { from, to } = action\n  const arrayToReorder =\n    from.jsonSubColumnModelIndex !== undefined\n      ? prevState[from.columnModelIndex].jsonSubColumns!\n      : prevState\n\n  const fromIndex =\n    from.jsonSubColumnModelIndex !== undefined\n      ? from.jsonSubColumnModelIndex\n      : from.columnModelIndex\n\n  const toIndex =\n    to.jsonSubColumnModelIndex !== undefined\n      ? to.jsonSubColumnModelIndex\n      : to.columnModelIndex\n\n  // Move the element\n  const newArray = moveElementInArray<unknown>(\n    arrayToReorder,\n    fromIndex,\n    toIndex,\n  ) as ColumnModelFormData[] | JsonSubColumnModelFormData[]\n\n  if (from.jsonSubColumnModelIndex !== undefined) {\n    // If we moved a jsonSubColumn, update state to use the new, reordered array\n    prevState[from.columnModelIndex].jsonSubColumns =\n      newArray as JsonSubColumnModelFormData[]\n    return prevState\n  } else {\n    // Otherwise, return the new, reordered array of column models\n    return newArray as ColumnModelFormData[]\n  }\n}\n\nexport function reducer(\n  prevState: ColumnModelFormData[],\n  action: TableColumnSchemaFormReducerAction,\n) {\n  switch (action.type) {\n    case 'setValue':\n      prevState = action.value\n      break\n    case 'toggleSelectAll': {\n      prevState = toggleSelectAll(prevState)\n      break\n    }\n    case 'setColumnModelValue': {\n      setColumnModelValue(action, prevState)\n      break\n    }\n    case 'changeColumnModelType': {\n      changeColumnModelType(action, prevState)\n      break\n    }\n\n    case 'appendColumn':\n      prevState.push(getDefaultColumnModelFormData())\n      break\n    case 'appendJsonSubColumn': {\n      const { columnModelIndex } = action\n      prevState[columnModelIndex] = {\n        ...prevState[columnModelIndex],\n        jsonSubColumns: [\n          ...(prevState[columnModelIndex].jsonSubColumns ?? []),\n          getDefaultJsonSubColumnFormData(),\n        ],\n      }\n      break\n    }\n    case 'toggleSelect': {\n      toggleSelect(action, prevState)\n      break\n    }\n    case 'delete':\n      prevState = deleteColumnModel(prevState)\n      break\n    case 'move': {\n      prevState = moveColumnModel(action, prevState)\n      break\n    }\n    case 'moveUp':\n      prevState = moveSelectedItemsUp(prevState, cm => cm.isSelected)\n      prevState.forEach(cm => {\n        if (cm.jsonSubColumns) {\n          cm.jsonSubColumns = moveSelectedItemsUp(\n            cm.jsonSubColumns,\n            jsc => jsc.isSelected,\n          )\n        }\n      })\n      break\n    case 'moveDown':\n      prevState = moveSelectedItemsDown(prevState, cm => cm.isSelected)\n      prevState.forEach(cm => {\n        if (cm.jsonSubColumns) {\n          cm.jsonSubColumns = moveSelectedItemsDown(\n            cm.jsonSubColumns,\n            jsc => jsc.isSelected,\n          )\n        }\n      })\n      break\n    default:\n      throw new Error(`Unexpected action`, action)\n  }\n  return [...prevState]\n}\n\nexport const tableColumnSchemaFormDataAtom = atomWithReducer<\n  ColumnModelFormData[],\n  TableColumnSchemaFormReducerAction\n>([], reducer)\n","import {\n  Box,\n  Fade,\n  FormControl,\n  Link,\n  MenuItem,\n  Select,\n  SxProps,\n  TextField,\n  Tooltip,\n} from '@mui/material'\nimport { useAtomValue, useSetAtom } from 'jotai'\nimport { selectAtom } from 'jotai/utils'\nimport {\n  ColumnModelFormData,\n  JsonSubColumnModelFormData,\n  tableColumnSchemaFormDataAtom,\n} from './TableColumnSchemaFormReducer'\nimport {\n  ColumnTypeEnum,\n  EntityType,\n  FacetType,\n  VIEW_CONCRETE_TYPE_VALUES,\n} from '@sage-bionetworks/synapse-types'\nimport { convertToConcreteEntityType } from '../../utils/functions/EntityTypeUtils'\nimport React, { useMemo, useState } from 'react'\nimport { isEmpty, isEqual } from 'lodash-es'\nimport {\n  canHaveDefault,\n  canHaveMaxListLength,\n  canHaveRestrictedValues,\n  canHaveSize,\n  configureFacetsForType,\n  getAllowedColumnTypes,\n  getColumnTypeFriendlyName,\n  getFacetTypeFriendlyName,\n  getMaxSizeForType,\n} from './TableColumnSchemaEditorUtils'\nimport { Checkbox } from '../widgets/Checkbox'\nimport JSONArrayEditorModal from '../JSONArrayEditor/JSONArrayEditorModal'\nimport { HIERARCHY_VERTICAL_LINE_COMPONENT } from './TableColumnSchemaForm'\nimport { InfoTwoTone } from '@mui/icons-material'\n\ntype ColumnModelFormProps = {\n  entityType: EntityType\n  columnModelIndex: number\n  jsonSubColumnIndex?: number\n  /* Default Columns are read-only, except for the facetType */\n  isDefaultColumn: boolean\n  disabled?: boolean\n}\nconst jsonSubColumnFieldSx: SxProps = {\n  height: '28px',\n  fontSize: '12px',\n}\nconst topLevelColumnModelFieldSx: SxProps = {\n  height: '38px',\n  fontSize: '14px',\n}\n\n/*\n * Disable immediate MUI/Emotion style injection because it causes performance issues when adding many columns at once.\n * This can be a common occurence when adding annotation columns\n */\nconst DISABLE_INJECTING_GLOBAL_STYLES_VALUE = true\n\nexport default function ColumnModelForm(props: ColumnModelFormProps) {\n  const {\n    columnModelIndex,\n    jsonSubColumnIndex,\n    entityType,\n    isDefaultColumn,\n    disabled = false,\n  } = props\n  const isJsonSubColumn = jsonSubColumnIndex != undefined\n  const dispatch = useSetAtom(tableColumnSchemaFormDataAtom)\n  const isView = (VIEW_CONCRETE_TYPE_VALUES as readonly string[]).includes(\n    convertToConcreteEntityType(entityType),\n  )\n\n  const [isShowingRestrictedValuesModal, setIsShowingRestrictedValuesModal] =\n    useState(false)\n\n  const columnModelAtom = useMemo(\n    () =>\n      selectAtom(\n        tableColumnSchemaFormDataAtom,\n        v =>\n          isJsonSubColumn\n            ? v[columnModelIndex].jsonSubColumns![jsonSubColumnIndex]\n            : v[columnModelIndex],\n        isEqual,\n      ),\n    [columnModelIndex, isJsonSubColumn, jsonSubColumnIndex],\n  )\n\n  const columnModel = useAtomValue(columnModelAtom)\n\n  const allowedColumnTypes = useMemo(\n    () => getAllowedColumnTypes(isView, isJsonSubColumn),\n    [isView, isJsonSubColumn],\n  )\n\n  const allowedFacetTypes = useMemo(\n    () => configureFacetsForType(columnModel.columnType, isJsonSubColumn),\n    [columnModel.columnType, isJsonSubColumn],\n  )\n  const fieldSx: SxProps = useMemo(\n    () => (isJsonSubColumn ? jsonSubColumnFieldSx : topLevelColumnModelFieldSx),\n    [isJsonSubColumn],\n  )\n\n  return (\n    <>\n      {isJsonSubColumn && (\n        <Box sx={{ gridColumn: '1 / span 1' }}>\n          {HIERARCHY_VERTICAL_LINE_COMPONENT}\n        </Box>\n      )}\n      <Box\n        data-testid={`ColumnModelForm`}\n        display={'flex'}\n        alignItems={'center'}\n        sx={{\n          gridColumn: isJsonSubColumn ? '2 / span 1' : ' 1 / span 1',\n          // Style hack to vertically center our custom checkbox component.\n          mb: '-5px',\n        }}\n      >\n        <Checkbox\n          label={'Select'}\n          hideLabel\n          checked={columnModel.isSelected}\n          disabled={disabled}\n          onChange={() => {\n            dispatch({\n              type: 'toggleSelect',\n              columnModelIndex,\n              jsonSubColumnModelIndex: jsonSubColumnIndex,\n            })\n          }}\n        />\n      </Box>\n      <Box\n        sx={{\n          my: 'auto',\n          gridColumn: isJsonSubColumn\n            ? /* If this is a JSON Subcolumn, we reduce the width of this grid column to create space to render the visual hierarchical line */\n              '3 / span 1'\n            : /* Otherwise, span across both grid columns  */\n              '2 / span 2',\n        }}\n      >\n        {isDefaultColumn ? (\n          columnModel.name\n        ) : (\n          <TextField\n            value={columnModel.name}\n            placeholder={isJsonSubColumn ? 'Facet name' : 'Column name'}\n            onChange={e => {\n              dispatch({\n                type: 'setColumnModelValue',\n                columnModelIndex,\n                jsonSubColumnModelIndex: jsonSubColumnIndex,\n                value: {\n                  ...columnModel,\n                  name: e.target.value,\n                },\n              })\n            }}\n            InputProps={{\n              disableInjectingGlobalStyles:\n                DISABLE_INJECTING_GLOBAL_STYLES_VALUE,\n              sx: fieldSx,\n              inputProps: {\n                'aria-label': 'Name',\n              },\n            }}\n            disabled={disabled}\n            fullWidth\n          />\n        )}\n      </Box>\n      <Box my={'auto'}>\n        {isDefaultColumn ? (\n          getColumnTypeFriendlyName(columnModel.columnType)\n        ) : (\n          <FormControl fullWidth>\n            <Select\n              label=\"Column Type\"\n              value={columnModel.columnType}\n              onChange={e => {\n                dispatch({\n                  type: 'changeColumnModelType',\n                  columnModelIndex,\n                  jsonSubColumnModelIndex: jsonSubColumnIndex,\n                  newColumnType: e.target.value as ColumnTypeEnum,\n                })\n              }}\n              inputProps={{\n                'aria-label': 'Column Type',\n              }}\n              sx={fieldSx}\n              MenuProps={{\n                TransitionComponent: Fade,\n              }}\n              disabled={disabled}\n            >\n              {allowedColumnTypes.map(value => {\n                return (\n                  <MenuItem value={value} key={value}>\n                    {getColumnTypeFriendlyName(value)}\n                  </MenuItem>\n                )\n              })}\n            </Select>\n          </FormControl>\n        )}\n      </Box>\n      <Box>\n        {isDefaultColumn ? (\n          (columnModel as ColumnModelFormData).maximumSize ?? ''\n        ) : (\n          <TextField\n            type={'number'}\n            value={(columnModel as ColumnModelFormData).maximumSize ?? ''}\n            disabled={disabled || !canHaveSize(columnModel.columnType)}\n            InputProps={{\n              disableInjectingGlobalStyles:\n                DISABLE_INJECTING_GLOBAL_STYLES_VALUE,\n\n              inputProps: {\n                'aria-label': 'Maximum Size',\n                min: 0,\n                max: canHaveSize(columnModel.columnType)\n                  ? getMaxSizeForType(columnModel.columnType)\n                  : undefined,\n              },\n              sx: fieldSx,\n            }}\n            onChange={e => {\n              dispatch({\n                type: 'setColumnModelValue',\n                columnModelIndex,\n                jsonSubColumnModelIndex: jsonSubColumnIndex,\n                value: {\n                  ...columnModel,\n                  maximumSize: parseInt(e.target.value),\n                },\n              })\n            }}\n            fullWidth\n          />\n        )}\n      </Box>\n      <Box>\n        {isDefaultColumn ? (\n          (columnModel as ColumnModelFormData).maximumListLength ?? ''\n        ) : (\n          <TextField\n            type={'number'}\n            value={(columnModel as ColumnModelFormData).maximumListLength ?? ''}\n            disabled={disabled || !canHaveMaxListLength(columnModel.columnType)}\n            onChange={e => {\n              dispatch({\n                type: 'setColumnModelValue',\n                columnModelIndex,\n                jsonSubColumnModelIndex: jsonSubColumnIndex,\n                value: {\n                  ...columnModel,\n                  maximumListLength: parseInt(e.target.value),\n                },\n              })\n            }}\n            InputProps={{\n              disableInjectingGlobalStyles:\n                DISABLE_INJECTING_GLOBAL_STYLES_VALUE,\n              inputProps: {\n                'aria-label': 'Maximum List Length',\n              },\n              sx: fieldSx,\n            }}\n            fullWidth\n          />\n        )}\n      </Box>\n      <Box>\n        {isDefaultColumn ? (\n          (columnModel as ColumnModelFormData)?.defaultValue ?? ''\n        ) : (\n          <TextField\n            fullWidth\n            value={(columnModel as ColumnModelFormData)?.defaultValue ?? ''}\n            disabled={\n              disabled ||\n              !canHaveDefault(columnModel.columnType, isView, isJsonSubColumn)\n            }\n            onChange={e => {\n              dispatch({\n                type: 'setColumnModelValue',\n                columnModelIndex,\n                jsonSubColumnModelIndex: jsonSubColumnIndex,\n                value: {\n                  ...columnModel,\n                  defaultValue: e.target.value,\n                },\n              })\n            }}\n            InputProps={{\n              disableInjectingGlobalStyles:\n                DISABLE_INJECTING_GLOBAL_STYLES_VALUE,\n              inputProps: {\n                'aria-label': 'Default Value',\n              },\n              sx: fieldSx,\n            }}\n          />\n        )}\n      </Box>\n      <Box>\n        <JSONArrayEditorModal\n          isShowingModal={isShowingRestrictedValuesModal}\n          onConfirm={newValue => {\n            dispatch({\n              type: 'setColumnModelValue',\n              columnModelIndex,\n              jsonSubColumnModelIndex: jsonSubColumnIndex,\n              value: {\n                ...columnModel,\n                enumValues: isEmpty(newValue) ? undefined : newValue,\n              },\n            })\n            setIsShowingRestrictedValuesModal(false)\n          }}\n          onCancel={() => setIsShowingRestrictedValuesModal(false)}\n        />\n        <TextField\n          fullWidth\n          value={((columnModel as ColumnModelFormData)?.enumValues ?? []).join(\n            ', ',\n          )}\n          onClick={() => {\n            setIsShowingRestrictedValuesModal(true)\n          }}\n          disabled={\n            disabled ||\n            !canHaveRestrictedValues(columnModel.columnType, isJsonSubColumn)\n          }\n          InputProps={{\n            disableInjectingGlobalStyles: DISABLE_INJECTING_GLOBAL_STYLES_VALUE,\n            // Is readOnly because edits are made with the JSONArrayEditorModal\n            readOnly: true,\n            sx: fieldSx,\n            inputProps: {\n              'aria-label': 'Restrict Values',\n            },\n          }}\n        />\n      </Box>\n      <Box>\n        <FormControl fullWidth>\n          <Select\n            label=\"Facet Type\"\n            value={columnModel.facetType}\n            disabled={disabled || allowedFacetTypes === null}\n            MenuProps={{\n              TransitionComponent: Fade,\n            }}\n            onChange={e => {\n              dispatch({\n                type: 'setColumnModelValue',\n                columnModelIndex,\n                jsonSubColumnModelIndex: jsonSubColumnIndex,\n                value: {\n                  ...columnModel,\n                  facetType: e.target.value as FacetType,\n                },\n              })\n            }}\n            sx={fieldSx}\n            inputProps={{\n              'aria-label': 'Facet Type',\n            }}\n          >\n            {(allowedFacetTypes ?? []).map((value, index) => {\n              return (\n                <MenuItem value={value} key={index}>\n                  {value === undefined ? '' : getFacetTypeFriendlyName(value)}\n                </MenuItem>\n              )\n            })}\n          </Select>\n        </FormControl>\n      </Box>\n      {isJsonSubColumn && (\n        <>\n          <Box\n            sx={{\n              gridColumn: '1 / span 1',\n            }}\n          >\n            {HIERARCHY_VERTICAL_LINE_COMPONENT}\n          </Box>\n          <Box></Box>\n          <Box\n            sx={{\n              gridColumn: '3 / span 7',\n            }}\n          >\n            <TextField\n              placeholder={'JSON Path'}\n              value={(columnModel as JsonSubColumnModelFormData).jsonPath}\n              onChange={e => {\n                dispatch({\n                  type: 'setColumnModelValue',\n                  columnModelIndex,\n                  jsonSubColumnModelIndex: jsonSubColumnIndex,\n                  value: {\n                    ...(columnModel as JsonSubColumnModelFormData),\n                    jsonPath: e.target.value,\n                  },\n                })\n              }}\n              disabled={disabled}\n              fullWidth\n              InputProps={{\n                disableInjectingGlobalStyles:\n                  DISABLE_INJECTING_GLOBAL_STYLES_VALUE,\n                sx: fieldSx,\n                endAdornment: (\n                  <Tooltip\n                    title={\n                      <React.Fragment>\n                        <p>\n                          <Link\n                            href={\n                              'https://dev.mysql.com/doc/refman/8.0/en/json.html#json-path-syntax'\n                            }\n                          >\n                            Please use a valid JSON Path selector, following\n                            this format.\n                          </Link>\n                        </p>\n                        <p>\n                          This field is for linking the sub-column facet to the\n                          corresponding location in the JSON data, so that it\n                          can be used as facet filter. The correct selector will\n                          point to the key referenced in the sub-column JSON\n                          Path.\n                        </p>\n                      </React.Fragment>\n                    }\n                  >\n                    <InfoTwoTone sx={{ color: 'grey.700' }} />\n                  </Tooltip>\n                ),\n                inputProps: {\n                  'aria-label': 'JSON Path',\n                },\n              }}\n            />\n          </Box>\n        </>\n      )}\n    </>\n  )\n}\n","import {\n  ColumnModel,\n  ViewColumnModelRequest,\n  ViewEntityType,\n} from '@sage-bionetworks/synapse-types'\nimport { useQuery, UseQueryOptions } from 'react-query'\nimport { SynapseClientError, useSynapseContext } from '../../utils'\nimport SynapseClient from '../../synapse-client'\n\nexport function useGetDefaultColumnModels(\n  viewEntityType: ViewEntityType,\n  viewTypeMask?: number,\n  options?: UseQueryOptions<ColumnModel[], SynapseClientError>,\n) {\n  const { keyFactory } = useSynapseContext()\n  return useQuery<ColumnModel[], SynapseClientError>(\n    keyFactory.getDefaultColumnModelsQueryKey(viewEntityType, viewTypeMask),\n    async () => {\n      return (\n        await SynapseClient.getDefaultColumnModels(viewEntityType, viewTypeMask)\n      ).list\n    },\n    options,\n  )\n}\n\nexport function useGetAnnotationColumnModels(\n  request: Omit<ViewColumnModelRequest, 'nextPageToken'>,\n  options?: UseQueryOptions<ColumnModel[], SynapseClientError>,\n) {\n  const { keyFactory } = useSynapseContext()\n  return useQuery<ColumnModel[], SynapseClientError>(\n    keyFactory.getAnnotationColumnModelsQueryKey(request),\n    () => SynapseClient.getAnnotationColumnModels(request),\n    options,\n  )\n}\n","import React, { useCallback, useState } from 'react'\nimport { Button } from '@mui/material'\nimport { DownloadTwoTone } from '@mui/icons-material'\nimport { SetOptional } from 'type-fest'\nimport {\n  ColumnModel,\n  EntityType,\n  Reference,\n} from '@sage-bionetworks/synapse-types'\nimport { EntityFinderModal } from '../EntityFinder/EntityFinderModal'\nimport { FinderScope } from '../EntityFinder/tree/EntityTree'\nimport { VersionSelectionType } from '../EntityFinder/VersionSelectionType'\nimport { EntityTypeGroup } from '../../utils/functions/EntityTypeUtils'\nimport SynapseClient from '../../synapse-client'\nimport { useSynapseContext } from '../../utils'\nimport { displayToast } from '../ToastMessage'\n\nexport type ImportTableColumnsButtonProps = {\n  initialFinderProjectId?: string\n  onAddColumns: (columnModels: SetOptional<ColumnModel, 'id'>[]) => void\n}\n\nexport default function ImportTableColumnsButton(\n  props: ImportTableColumnsButtonProps,\n) {\n  const { initialFinderProjectId, onAddColumns } = props\n  const [showFinder, setShowFinder] = useState(false)\n  const { accessToken } = useSynapseContext()\n\n  const fetchColumnModels = useCallback(\n    async (reference: Reference): Promise<SetOptional<ColumnModel, 'id'>[]> => {\n      const { tableBundle } = await SynapseClient.getEntityBundleV2(\n        reference.targetId,\n        { includeTableBundle: true },\n        reference.targetVersionNumber,\n        accessToken,\n      )\n      return tableBundle!.columnModels.map(columnModel => ({\n        ...columnModel,\n        id: undefined,\n      }))\n    },\n    [accessToken],\n  )\n\n  const onConfirmEntityFinder = useCallback(\n    async (selected: Reference[]) => {\n      try {\n        const selectedEntity = selected[0]\n\n        if (selectedEntity) {\n          // Get the column models from the selected table\n          const columnModels = await fetchColumnModels(selectedEntity)\n          onAddColumns(columnModels)\n        }\n      } catch (err) {\n        console.error(err)\n        displayToast(err.message, 'danger')\n      } finally {\n        setShowFinder(false)\n      }\n    },\n    [fetchColumnModels, onAddColumns],\n  )\n\n  return (\n    <>\n      <EntityFinderModal\n        configuration={{\n          initialScope: initialFinderProjectId\n            ? FinderScope.CURRENT_PROJECT\n            : FinderScope.ALL_PROJECTS,\n          initialContainer: initialFinderProjectId ?? 'root',\n          selectMultiple: false,\n          selectableTypes: EntityTypeGroup.ALL_TABLES,\n          visibleTypesInTree: [EntityType.PROJECT],\n          versionSelection: VersionSelectionType.UNTRACKED,\n        }}\n        show={showFinder}\n        title={'Import Columns from Table'}\n        promptCopy={'Find Tables to import columns'}\n        titleHelpPopoverProps={{\n          markdownText:\n            'Search or Browse Synapse to find an existing Table in order to import columns into this Table',\n        }}\n        onConfirm={selected => {\n          onConfirmEntityFinder(selected)\n        }}\n        confirmButtonCopy={'Import Columns'}\n        onCancel={() => {\n          setShowFinder(false)\n        }}\n      />\n      <Button\n        variant={'outlined'}\n        onClick={() => {\n          setShowFinder(true)\n        }}\n        startIcon={<DownloadTwoTone />}\n      >\n        Import Columns\n      </Button>\n    </>\n  )\n}\n","import {\n  ColumnModel,\n  ColumnTypeEnum,\n  EntityType,\n  VIEW_CONCRETE_TYPE_VALUES,\n  ViewScope,\n} from '@sage-bionetworks/synapse-types'\nimport { atom, useAtomValue, useSetAtom } from 'jotai'\nimport React, {\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n} from 'react'\nimport {\n  ColumnModelFormData,\n  getIsAllSelected,\n  getNumberOfSelectedItems,\n  tableColumnSchemaFormDataAtom,\n} from './TableColumnSchemaFormReducer'\nimport {\n  Box,\n  BoxProps,\n  Button,\n  ButtonGroup,\n  Checkbox as MUICheckbox,\n  styled,\n  Typography,\n} from '@mui/material'\nimport { isEqual, noop, times } from 'lodash-es'\nimport { selectAtom, useAtomCallback } from 'jotai/utils'\nimport ColumnModelForm from './ColumnModelForm'\nimport AddToList from '../../assets/icons/AddToList'\nimport { AddCircleTwoTone, North, South } from '@mui/icons-material'\nimport IconSvg from '../IconSvg'\nimport {\n  convertToConcreteEntityType,\n  entityTypeToFriendlyName,\n} from '../../utils/functions/EntityTypeUtils'\nimport {\n  getAllowedColumnTypes,\n  transformColumnModelsToFormData,\n  transformFormDataToColumnModels,\n} from './TableColumnSchemaEditorUtils'\nimport {\n  useGetAnnotationColumnModels,\n  useGetDefaultColumnModels,\n} from '../../synapse-queries/table/useColumnModel'\nimport { SynapseSpinner } from '../LoadingScreen/LoadingScreen'\nimport { displayToast } from '../ToastMessage'\nimport { StyledComponent } from '@emotion/styled/dist/emotion-styled.cjs'\nimport ImportTableColumnsButton from './ImportTableColumnsButton'\nimport { SetOptional } from 'type-fest'\n\nconst COLUMN_SCHEMA_FORM_GRID_TEMPLATE_COLUMNS =\n  '18px 18px 1.75fr 1.75fr 0.75fr 1fr 1.25fr 1.25fr 1fr'\nconst GRID_CONTAINER_Y_MARGIN_PX = 6\nexport const HIERARCHY_VERTICAL_LINE_COMPONENT = (\n  <Box\n    sx={{\n      width: '1px',\n      height: `calc(100% + 2 * ${GRID_CONTAINER_Y_MARGIN_PX}px)`,\n      backgroundColor: 'grey.400',\n      marginLeft: '8px',\n    }}\n  />\n)\nexport const HIERARCHY_END_COMPONENT = (\n  <Box\n    sx={theme => ({\n      width: '50%',\n      height: '60%',\n      borderLeft: `1px solid ${theme.palette.grey[400]}`,\n      borderBottom: `1px solid ${theme.palette.grey[400]}`,\n      marginLeft: '8px',\n      marginBottom: 'auto',\n      marginRight: '0',\n      borderBottomLeftRadius: '5px',\n    })}\n  />\n)\n\nexport type SubmitHandle = {\n  // Allow the parent component to trigger a submit of the form, so this may be embedded in an arbitrary modal.\n  submit: () => void\n  // Imperative handle to get the data out of the form for SWC compatibility\n  getEditedColumnModels: () => SetOptional<ColumnModel, 'id'>[]\n}\n\ntype TableColumnSchemaFormProps = {\n  /* The type of the Table, which determines various schema restrictions and form functionality */\n  entityType: EntityType\n  /* If this is an entity view, the ViewScope can be used to determine the default column models and fetch annotation column models */\n  viewScope?: ViewScope\n  initialData?: ColumnModel[]\n  onSubmit?: (formData: ColumnModelFormData[]) => void\n  isSubmitting?: boolean\n}\n\nconst ColumnHeader: StyledComponent<BoxProps> = styled(Box, {\n  label: 'ColumnHeader',\n})({\n  fontWeight: 700,\n})\n\nconst TableColumnSchemaForm = React.forwardRef<\n  SubmitHandle,\n  TableColumnSchemaFormProps\n>(function TableColumnSchemaForm(props, ref) {\n  const {\n    initialData,\n    entityType,\n    viewScope,\n    onSubmit = noop,\n    isSubmitting = false,\n  } = props\n\n  const numColumnModels = useAtomValue(\n    useMemo(() => atom(get => get(tableColumnSchemaFormDataAtom).length), []),\n  )\n\n  const dispatch = useSetAtom(tableColumnSchemaFormDataAtom)\n\n  // useAtomCallback will let us imperatively read the form data, instead of tracking it in state and triggering a full re-render of the form when any data changes\n  const readFormData = useAtomCallback(\n    useCallback(get => {\n      return get(tableColumnSchemaFormDataAtom)\n    }, []),\n  )\n  const concreteTableType = convertToConcreteEntityType(entityType)\n  const isView = VIEW_CONCRETE_TYPE_VALUES.includes(\n    concreteTableType as (typeof VIEW_CONCRETE_TYPE_VALUES)[number],\n  )\n  const hasAnnotationColumnModels = isView,\n    hasDefaultColumnModels = isView\n\n  const { data: defaultColumnModels, isLoading: isLoadingDefaultColumns } =\n    useGetDefaultColumnModels(\n      viewScope?.viewEntityType!,\n      viewScope?.viewTypeMask,\n      {\n        enabled: hasDefaultColumnModels,\n        staleTime: Infinity, // The default column models will never change\n      },\n    )\n\n  const {\n    data: annotationColumnModels,\n    isLoading: isLoadingAnnotationColumns,\n  } = useGetAnnotationColumnModels(\n    {\n      viewScope: viewScope!,\n      includeDerivedAnnotations: true,\n      concreteType:\n        'org.sagebionetworks.repo.model.table.ViewColumnModelRequest',\n    },\n    {\n      enabled: hasAnnotationColumnModels,\n    },\n  )\n\n  /**\n   * Set the initialData in the form state atom on mount, if it exists and we have no data.\n   */\n  useEffect(() => {\n    if (initialData && !isLoadingDefaultColumns) {\n      dispatch({\n        type: 'setValue',\n        value: transformColumnModelsToFormData(\n          initialData,\n          defaultColumnModels ?? [],\n        ),\n      })\n    }\n    // Don't re-run if initial data changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoadingDefaultColumns])\n\n  useImperativeHandle(\n    ref,\n    () => {\n      return {\n        submit() {\n          onSubmit(readFormData())\n        },\n        getEditedColumnModels() {\n          return transformFormDataToColumnModels(readFormData())\n        },\n      }\n    },\n    [onSubmit, readFormData],\n  )\n\n  // Generic function to add a set of columns to the schema (e.g. default columns, annotation columns)\n  const addColumnSet = useCallback(\n    (newColumns: SetOptional<ColumnModel, 'id'>[]) => {\n      const currentFormData = readFormData()\n      const columnsToAdd = newColumns.filter(\n        (cm: SetOptional<ColumnModel, 'id'>) => {\n          // Don't add columns that cannot be added (for example, Views cannot have JSON columns)\n          if (\n            !getAllowedColumnTypes(isView, false).includes(\n              cm.columnType as ColumnTypeEnum,\n            )\n          ) {\n            return false\n          }\n          // Only add columns that are not already present\n          // Use the name column to match because the ID may vary, e.g. if the facetType was changed\n          return !currentFormData.find(fd => fd.name === cm.name)\n        },\n      )\n      if (columnsToAdd.length > 0) {\n        dispatch({\n          type: 'setValue',\n          value: [\n            ...currentFormData,\n            ...transformColumnModelsToFormData(\n              columnsToAdd,\n              defaultColumnModels,\n            ),\n          ],\n        })\n        displayToast(\n          `${columnsToAdd.length} columns added to schema.`,\n          'success',\n        )\n      } else {\n        displayToast(\n          'No columns added. All columns to add are present in the column schema.',\n          'info',\n        )\n      }\n    },\n    [defaultColumnModels, dispatch, isView, readFormData],\n  )\n\n  const addDefaultColumns = useCallback(() => {\n    if (defaultColumnModels) {\n      addColumnSet(\n        defaultColumnModels.map(cm => ({\n          ...cm,\n          id: undefined,\n        })),\n      )\n    }\n  }, [defaultColumnModels, addColumnSet])\n\n  const addAnnotationColumns = useCallback(() => {\n    if (annotationColumnModels) {\n      addColumnSet(annotationColumnModels)\n    }\n  }, [annotationColumnModels, addColumnSet])\n\n  return (\n    <Box\n      component={'form'}\n      sx={{\n        py: 2.5,\n      }}\n    >\n      <TableColumnSchemaFormActions disabled={isSubmitting} />\n      <Box\n        display={'grid'}\n        sx={{\n          gridTemplateColumns: COLUMN_SCHEMA_FORM_GRID_TEMPLATE_COLUMNS,\n          py: 2.5,\n        }}\n        gap={'8px'}\n      >\n        <ColumnHeader>{/* Checkbox */}</ColumnHeader>\n        <ColumnHeader sx={{ gridColumn: '2 / span 2' }}>\n          Column Name\n        </ColumnHeader>\n        <ColumnHeader>Column Type</ColumnHeader>\n        <ColumnHeader>Size</ColumnHeader>\n        <ColumnHeader>Max List Length</ColumnHeader>\n        <ColumnHeader>Default Value</ColumnHeader>\n        <ColumnHeader>Restrict Values</ColumnHeader>\n        <ColumnHeader>Facet</ColumnHeader>\n        <Box\n          sx={{\n            gridColumn: '1 / span 10',\n            backgroundColor: 'grey.300',\n            height: '2px',\n          }}\n        />\n        {times(numColumnModels, index => {\n          return (\n            <TableColumnSchemaFormRow\n              entityType={entityType}\n              columnModelIndex={index}\n              disabled={isSubmitting}\n              key={index}\n            />\n          )\n        })}\n      </Box>\n\n      <Box display={'flex'} gap={1}>\n        <Button\n          variant={'outlined'}\n          onClick={() => {\n            dispatch({ type: 'appendColumn' })\n          }}\n          startIcon={<AddCircleTwoTone />}\n          disabled={isSubmitting}\n        >\n          Add Column\n        </Button>\n\n        {hasDefaultColumnModels && (\n          <Button\n            variant={'outlined'}\n            startIcon={\n              isLoadingDefaultColumns ? (\n                <SynapseSpinner />\n              ) : (\n                <AddCircleTwoTone />\n              )\n            }\n            onClick={() => {\n              addDefaultColumns()\n            }}\n            disabled={isLoadingDefaultColumns || isSubmitting}\n          >\n            Add Default {entityTypeToFriendlyName(entityType)} Columns\n          </Button>\n        )}\n\n        {hasAnnotationColumnModels && (\n          <Button\n            variant={'outlined'}\n            startIcon={\n              isLoadingAnnotationColumns ? (\n                <SynapseSpinner />\n              ) : (\n                <AddCircleTwoTone />\n              )\n            }\n            disabled={isLoadingAnnotationColumns || isSubmitting}\n            onClick={() => {\n              addAnnotationColumns()\n            }}\n          >\n            Add All Annotations\n          </Button>\n        )}\n        <ImportTableColumnsButton\n          onAddColumns={cms => {\n            addColumnSet(cms)\n          }}\n        />\n      </Box>\n    </Box>\n  )\n})\n\ntype TableColumnSchemaFormActionsProps = {\n  disabled?: boolean\n}\n\nfunction TableColumnSchemaFormActions(\n  props: TableColumnSchemaFormActionsProps,\n) {\n  const { disabled = false } = props\n  const dispatch = useSetAtom(tableColumnSchemaFormDataAtom)\n\n  const columnModels = useAtomValue(tableColumnSchemaFormDataAtom)\n  const allSelected = getIsAllSelected(columnModels)\n  const numSelected = getNumberOfSelectedItems(columnModels)\n\n  return (\n    <Box display={'flex'} gap={1}>\n      <Button\n        aria-label={'Select All'}\n        variant={'outlined'}\n        color={'neutral'}\n        onClick={() => {\n          dispatch({ type: 'toggleSelectAll' })\n        }}\n        disabled={disabled || columnModels.length == 0}\n      >\n        {/*\n           MUI Checkbox looks a little different from ours, but it has an indeterminate state\n           TODO: reconcile these differences\n          */}\n        <MUICheckbox\n          size={'small'}\n          checked={allSelected}\n          indeterminate={numSelected > 0 && !allSelected}\n          disabled={disabled || columnModels.length == 0}\n        />\n        <Typography variant=\"smallText1\" color={'text.secondary'}>\n          {numSelected} selected\n        </Typography>\n      </Button>\n      <ButtonGroup>\n        <Button\n          aria-label={'Move Down'}\n          variant={'outlined'}\n          color={'neutral'}\n          onClick={() => {\n            dispatch({ type: 'moveDown' })\n          }}\n          disabled={disabled || numSelected == 0}\n        >\n          <South fontSize={'small'} />\n        </Button>\n        <Button\n          aria-label={'Move Up'}\n          variant={'outlined'}\n          color={'neutral'}\n          onClick={() => {\n            dispatch({ type: 'moveUp' })\n          }}\n          disabled={disabled || numSelected == 0}\n        >\n          <North fontSize={'small'} />\n        </Button>\n      </ButtonGroup>\n      <Button\n        aria-label={'Delete'}\n        variant={'outlined'}\n        color={'neutral'}\n        onClick={() => {\n          dispatch({ type: 'delete' })\n        }}\n        disabled={disabled || numSelected == 0}\n      >\n        <IconSvg fontSize={'small'} icon={'delete'} wrap={false} />\n      </Button>\n    </Box>\n  )\n}\n\ntype TableColumnSchemaFormRowProps = {\n  entityType: EntityType\n  columnModelIndex: number\n  disabled: boolean\n}\n\nfunction TableColumnSchemaFormRow(props: TableColumnSchemaFormRowProps) {\n  const { columnModelIndex, entityType, disabled } = props\n  const dispatch = useSetAtom(tableColumnSchemaFormDataAtom)\n  const columnModel = useAtomValue(\n    useMemo(\n      () =>\n        selectAtom(\n          tableColumnSchemaFormDataAtom,\n          formData => formData[columnModelIndex],\n          isEqual,\n        ),\n      [columnModelIndex],\n    ),\n  )\n\n  if (!columnModel) {\n    return <></>\n  }\n  const isDefaultColumn = columnModel.isOriginallyDefaultColumn\n\n  return (\n    <>\n      <ColumnModelForm\n        entityType={entityType}\n        columnModelIndex={columnModelIndex}\n        isDefaultColumn={isDefaultColumn}\n        disabled={disabled}\n      />\n      {columnModel.columnType === ColumnTypeEnum.JSON &&\n        columnModel.jsonSubColumns &&\n        columnModel.jsonSubColumns.map((subColumnFacet, index) => (\n          <ColumnModelForm\n            key={index}\n            entityType={entityType}\n            columnModelIndex={columnModelIndex}\n            jsonSubColumnIndex={index}\n            isDefaultColumn={isDefaultColumn}\n            disabled={disabled}\n          />\n        ))}\n      {columnModel.columnType === ColumnTypeEnum.JSON && (\n        <>\n          <Box\n            sx={{\n              gridColumn: '1 / span 2',\n            }}\n          >\n            {HIERARCHY_END_COMPONENT}\n          </Box>\n          <Box>\n            <Button\n              startIcon={<AddToList />}\n              variant={'text'}\n              disabled={disabled}\n              onClick={() =>\n                dispatch({ type: 'appendJsonSubColumn', columnModelIndex })\n              }\n            >\n              Add sub-column\n            </Button>\n          </Box>\n        </>\n      )}\n    </>\n  )\n}\n\nexport default TableColumnSchemaForm\n","import React, { useCallback, useMemo, useRef } from 'react'\nimport {\n  useGetEntity,\n  useGetQueryResultBundleWithAsyncStatus,\n  useUpdateTableColumns,\n} from '../../synapse-queries'\nimport { BUNDLE_MASK_QUERY_COLUMN_MODELS } from '../../utils/SynapseConstants'\nimport { useDeepCompareMemoize } from 'use-deep-compare-effect'\nimport { SkeletonTable } from '../Skeleton'\nimport { convertToEntityType } from '../../utils/functions/EntityTypeUtils'\nimport TableColumnSchemaForm, { SubmitHandle } from './TableColumnSchemaForm'\nimport { Alert, Button, Divider } from '@mui/material'\nimport { ColumnModelFormData } from './TableColumnSchemaFormReducer'\nimport {\n  getViewScopeForEntity,\n  transformFormDataToColumnModels,\n} from './TableColumnSchemaEditorUtils'\nimport { useSynapseContext } from '../../utils'\nimport { ViewScope } from '@sage-bionetworks/synapse-types'\nimport { Provider } from 'jotai'\n\nexport type TableColumnSchemaEditorProps = {\n  entityId: string\n}\n\n/**\n * Fetches column model data for a Synapse Table and renders a form to edit the column models.\n * @param props\n * @constructor\n */\nfunction _TableColumnSchemaEditor(props: TableColumnSchemaEditorProps) {\n  const { entityId } = props\n\n  const formRef = useRef<SubmitHandle>(null)\n  const { data: entity, isLoading: isLoadingEntity } = useGetEntity(entityId)\n  const { data: _queryResultBundle, isLoading: isLoadingColumnModels } =\n    useGetQueryResultBundleWithAsyncStatus(\n      {\n        entityId,\n        query: {\n          sql: `SELECT * FROM ${entityId}`,\n        },\n        partMask: BUNDLE_MASK_QUERY_COLUMN_MODELS,\n        concreteType: 'org.sagebionetworks.repo.model.table.QueryBundleRequest',\n      },\n      {\n        // This data is inserted into a form, so don't refetch it.\n        staleTime: Infinity,\n        useErrorBoundary: true,\n      },\n    )\n\n  const { mutate, isLoading: isMutating, error } = useUpdateTableColumns()\n\n  const isLoading = isLoadingEntity || isLoadingColumnModels\n\n  // TODO: the hook above is not returning a stable reference. this is unexpected.\n  const queryResultBundle = useDeepCompareMemoize(_queryResultBundle)\n  const { accessToken } = useSynapseContext()\n  const onSubmit = useCallback(\n    (formData: ColumnModelFormData[]) => {\n      // Transform the form data into ColumnModels\n      const columnModels = transformFormDataToColumnModels(formData)\n\n      // Update the table schema with the new column models.\n      mutate({\n        entityId,\n        originalColumnModels: queryResultBundle!.responseBody!.columnModels!,\n        newColumnModels: columnModels,\n      })\n    },\n    [accessToken, entityId, mutate, queryResultBundle],\n  )\n\n  const viewScope: ViewScope | undefined = useMemo(() => {\n    if (!entity) {\n      return undefined\n    }\n    return getViewScopeForEntity(entity)\n  }, [entity])\n\n  if (isLoading || !entity) {\n    return (\n      <SkeletonTable\n        numRows={8}\n        numCols={7}\n        rowHeight={'50px'}\n        fullWidthCells\n      />\n    )\n  }\n\n  return (\n    <>\n      <TableColumnSchemaForm\n        ref={formRef}\n        entityType={convertToEntityType(entity.concreteType)}\n        viewScope={viewScope}\n        initialData={queryResultBundle?.responseBody?.columnModels}\n        isSubmitting={isMutating}\n        onSubmit={formData => {\n          onSubmit(formData)\n        }}\n      />\n      <Divider />\n      {error && (\n        <Alert severity={'error'} sx={{ my: 2 }}>\n          {error?.message}\n        </Alert>\n      )}\n      <Button\n        variant=\"contained\"\n        color=\"primary\"\n        onClick={() => {\n          if (formRef.current) {\n            formRef.current.submit()\n          }\n        }}\n        disabled={isMutating}\n        sx={{ my: 2 }}\n      >\n        {isMutating ? 'Saving...' : 'Save'}\n      </Button>\n    </>\n  )\n}\n\nexport default function TableColumnSchemaEditor(\n  props: TableColumnSchemaEditorProps,\n) {\n  // Wrap in a Jotai provider to ensure the Jotai atomic state is unique to this component tree\n  // i.e. other instances of TableColumnSchemaEditor will not share state with this instance\n  return (\n    <Provider>\n      <_TableColumnSchemaEditor {...props} />\n    </Provider>\n  )\n}\n"],"names":["DownloadTwoTone","createSvgIcon","_jsx","North","South","atomWithReducer","initialValue","reducer","anAtom","atom","get","set","action","getCached$2","c","m","k","cache1$4","memo3","create","dep1","dep2","dep3","cache2","cache3","selectAtom","selector","equalityFn","EMPTY","selectValue","value","prevSlice","slice","derivedAtom","prev","useAtomCallback","callback","options","useMemo","args","useSetAtom","unsupportedTypesForViews","ColumnTypeEnum","getAllowedColumnTypes","isView","isJsonSubColumnFacet","columnType","getFacetTypeFriendlyName","facetType","getColumnTypeFriendlyName","type","canHaveSize","canHaveMaxListLength","configureFacetsForType","allowedFacetTypes","canHaveDefault","DEFAULT_STRING_SIZE","MAX_STRING_SIZE","getMaxSizeForType","canHaveRestrictedValues","transformFormDataToColumnModels","formData","formEntry","isSelected","isOriginallyDefaultColumn","rest","columnModel","jsonSubColumnFormData","transformColumnModelsToFormData","columnModels","defaultColumns","cm","dcm","jsc","getViewScopeForEntity","entity","isEntityView","convertToEntityType","isDataset","isDatasetCollection","mask","ENTITY_VIEW_TYPE_MASK_FILE","ENTITY_VIEW_TYPE_MASK_DATASET","item","isSubmissionView","getIsAllSelected","getNumberOfSelectedItems","acc","curr","getDefaultColumnModelFormData","getDefaultJsonSubColumnFormData","moveSelectedItemsUp","arr","predicate","newArr","index","temp","moveSelectedItemsDown","i","changeColumnModelType","prevState","columnModelIndex","jsonSubColumnModelIndex","newColumnType","newColumnModelValue","cloneDeep","toggleSelectAll","_a","setColumnModelValue","toggleSelect","deleteColumnModel","moveElementInArray","arrayToReorder","fromIndex","toIndex","newArray","elementToMove","moveColumnModel","from","to","tableColumnSchemaFormDataAtom","jsonSubColumnFieldSx","topLevelColumnModelFieldSx","DISABLE_INJECTING_GLOBAL_STYLES_VALUE","ColumnModelForm","props","jsonSubColumnIndex","entityType","isDefaultColumn","disabled","isJsonSubColumn","dispatch","VIEW_CONCRETE_TYPE_VALUES","convertToConcreteEntityType","isShowingRestrictedValuesModal","setIsShowingRestrictedValuesModal","useState","columnModelAtom","v","isEqual","useAtomValue","allowedColumnTypes","fieldSx","jsxs","Fragment","jsx","Box","HIERARCHY_VERTICAL_LINE_COMPONENT","Checkbox","TextField","e","FormControl","Select","Fade","MenuItem","JSONArrayEditorModal","newValue","isEmpty","Tooltip","React","Link","InfoTwoTone","useGetDefaultColumnModels","viewEntityType","viewTypeMask","keyFactory","useSynapseContext","useQuery","SynapseClient","useGetAnnotationColumnModels","request","ImportTableColumnsButton","initialFinderProjectId","onAddColumns","showFinder","setShowFinder","accessToken","fetchColumnModels","useCallback","reference","tableBundle","onConfirmEntityFinder","selected","selectedEntity","err","displayToast","EntityFinderModal","FinderScope","EntityTypeGroup","EntityType","VersionSelectionType","Button","COLUMN_SCHEMA_FORM_GRID_TEMPLATE_COLUMNS","GRID_CONTAINER_Y_MARGIN_PX","HIERARCHY_END_COMPONENT","theme","ColumnHeader","styled","TableColumnSchemaForm","ref","initialData","viewScope","onSubmit","noop","isSubmitting","numColumnModels","readFormData","concreteTableType","hasAnnotationColumnModels","hasDefaultColumnModels","defaultColumnModels","isLoadingDefaultColumns","annotationColumnModels","isLoadingAnnotationColumns","useEffect","useImperativeHandle","addColumnSet","newColumns","currentFormData","columnsToAdd","fd","addDefaultColumns","addAnnotationColumns","TableColumnSchemaFormActions","times","TableColumnSchemaFormRow","AddCircleTwoTone","SynapseSpinner","entityTypeToFriendlyName","cms","allSelected","numSelected","MUICheckbox","Typography","ButtonGroup","IconSvg","subColumnFacet","AddToList","_TableColumnSchemaEditor","entityId","formRef","useRef","isLoadingEntity","useGetEntity","_queryResultBundle","isLoadingColumnModels","useGetQueryResultBundleWithAsyncStatus","BUNDLE_MASK_QUERY_COLUMN_MODELS","mutate","isMutating","error","useUpdateTableColumns","isLoading","queryResultBundle","useDeepCompareMemoize","SkeletonTable","Divider","Alert","TableColumnSchemaEditor","Provider"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}