{"version":3,"file":"sqlFunctions-88ebae8b.js","sources":["../../src/lib/utils/functions/sqlFunctions.ts"],"sourcesContent":["import { Row, SelectColumn } from '../synapseTypes'\nimport { SYNAPSE_ENTITY_ID_REGEX } from '../functions/RegularExpressions'\nimport {\n  ColumnMultiValueFunction,\n  ColumnMultiValueFunctionQueryFilter,\n  ColumnSingleValueFilterOperator,\n  ColumnSingleValueQueryFilter,\n  QueryFilter,\n} from '../synapseTypes/Table/QueryFilter'\n\nexport type SQLOperator = 'LIKE' | '=' | 'HAS'\n\nconst WITHOUT_SYN_PREFIX = 3\n/**\n * Given the search params, return a set of QueryFilters to narrow the the query to view just related data. May return null if a QueryFilter should not be added.\n * @param sql\n * @param searchParams\n * @param operator\n * @returns\n */\nexport const generateQueryFilterFromSearchParams = (\n  searchParams?: Record<string, string>,\n  operator: SQLOperator = 'LIKE',\n): QueryFilter[] | undefined => {\n  if (!searchParams) {\n    return\n  }\n  const isQueryWrapperKey = (key: string) => key.startsWith('QueryWrapper')\n  const searchParamKeys = Object.keys(searchParams)\n  if (\n    searchParamKeys.length === 0 ||\n    searchParamKeys.every(isQueryWrapperKey)\n  ) {\n    return\n  }\n\n  return Object.keys(searchParams)\n    .filter(key => !isQueryWrapperKey(key))\n    .map(key => {\n      if (operator === 'HAS') {\n        const filter: ColumnMultiValueFunctionQueryFilter = {\n          concreteType:\n            'org.sagebionetworks.repo.model.table.ColumnMultiValueFunctionQueryFilter',\n          columnName: key,\n          function: ColumnMultiValueFunction.HAS,\n          values: searchParams[key].split(','),\n        }\n        return filter\n      } else if (operator === 'LIKE') {\n        let value = searchParams[key]\n        if (value.match(SYNAPSE_ENTITY_ID_REGEX)) {\n          // If we use a LIKE statement with a synId the backend will look for a string with the first three\n          // characters being 'syn', however, it stores synIds without 'syn', so the query will fail\n          // The backend usually parses 'syn' out, but not with the LIKE clause since its expecting a regex, so we\n          // parse this out. This will cause a bug if something matches the synId regex but is in free text.\n          value = value.substring(WITHOUT_SYN_PREFIX)\n        }\n        const filter: ColumnSingleValueQueryFilter = {\n          concreteType:\n            'org.sagebionetworks.repo.model.table.ColumnSingleValueQueryFilter',\n          columnName: key,\n          operator: ColumnSingleValueFilterOperator.LIKE,\n          // Add wildcards around the value\n          values: [`%${value}%`],\n        }\n        return filter\n      } else {\n        // operator is '='\n        // The backend doesn't have an '=' operator for query filters, but we can just use LIKE without wildcards.\n        const filter: ColumnSingleValueQueryFilter = {\n          concreteType:\n            'org.sagebionetworks.repo.model.table.ColumnSingleValueQueryFilter',\n          columnName: key,\n          operator: ColumnSingleValueFilterOperator.LIKE,\n          values: [searchParams[key]],\n        }\n        return filter\n      }\n    })\n}\n\n//parses synapse entity id from a sql query string\n//look for a pattern of 'from[some number of spaces]syn[somenumbers]` case insensitive\nexport const parseEntityIdFromSqlStatement = (sql: string): string => {\n  const matches = sql.match(/(from)\\s+(syn)\\d+/gi)\n  return matches && matches[0] ? matches[0].substr(5).trim() : ''\n}\n\nexport const parseEntityIdAndVersionFromSqlStatement = (\n  sql: string,\n): { entityId: string; versionNumber?: number } | null => {\n  const regex = /from\\s+(syn\\d+)(?:\\.(\\d+))?/i\n  const matches = regex.exec(sql)\n  if (!matches) {\n    return null\n  }\n  return {\n    entityId: matches[1],\n    versionNumber: matches[2] ? parseInt(matches[2]) : undefined,\n  }\n}\n\nexport const resultToJson = <T>(\n  headerColumns: SelectColumn[],\n  rowColumns: Row[],\n): T[] => {\n  const result: T[] = []\n  const rows = rowColumns.map(row => row.values)\n  const headers = headerColumns.map(column => column.name)\n  rows.forEach((row, index) => {\n    result[index] = {} as T\n    row.forEach((text, cellIndex) => {\n      result[index][headers[cellIndex]] = text\n    })\n  })\n  return result\n}\n"],"names":["WITHOUT_SYN_PREFIX","generateQueryFilterFromSearchParams","searchParams","operator","isQueryWrapperKey","key","searchParamKeys","ColumnMultiValueFunction","value","SYNAPSE_ENTITY_ID_REGEX","ColumnSingleValueFilterOperator","parseEntityIdFromSqlStatement","sql","matches","parseEntityIdAndVersionFromSqlStatement","resultToJson","headerColumns","rowColumns","result","rows","row","headers","column","index","text","cellIndex"],"mappings":"0GAYA,MAAMA,EAAqB,EAQdC,EAAsC,CACjDC,EACAC,EAAwB,SACM,CAC9B,GAAI,CAACD,EACH,OAEF,MAAME,EAAqBC,GAAgBA,EAAI,WAAW,cAAc,EAClEC,EAAkB,OAAO,KAAKJ,CAAY,EAChD,GACE,EAAAI,EAAgB,SAAW,GAC3BA,EAAgB,MAAMF,CAAiB,GAKzC,OAAO,OAAO,KAAKF,CAAY,EAC5B,OAAOG,GAAO,CAACD,EAAkBC,CAAG,CAAC,EACrC,IAAWA,GAAA,CACV,GAAIF,IAAa,MAQR,MAP6C,CAClD,aACE,2EACF,WAAYE,EACZ,SAAUE,EAAyB,IACnC,OAAQL,EAAaG,CAAG,EAAE,MAAM,GAAG,CAAA,EAGvC,GAAWF,IAAa,OAAQ,CAC1B,IAAAK,EAAQN,EAAaG,CAAG,EACxB,OAAAG,EAAM,MAAMC,CAAuB,IAK7BD,EAAAA,EAAM,UAAUR,CAAkB,GAEC,CAC3C,aACE,oEACF,WAAYK,EACZ,SAAUK,EAAgC,KAE1C,OAAQ,CAAC,IAAIF,IAAQ,CAAA,CAEhB,KAWA,OAPsC,CAC3C,aACE,oEACF,WAAYH,EACZ,SAAUK,EAAgC,KAC1C,OAAQ,CAACR,EAAaG,CAAG,CAAC,CAAA,CAG9B,CACD,CACL,EAIaM,EAAiCC,GAAwB,CAC9D,MAAAC,EAAUD,EAAI,MAAM,qBAAqB,EACxC,OAAAC,GAAWA,EAAQ,CAAC,EAAIA,EAAQ,CAAC,EAAE,OAAO,CAAC,EAAE,KAAA,EAAS,EAC/D,EAEaC,EACXF,GACwD,CAElD,MAAAC,EADQ,+BACQ,KAAKD,CAAG,EAC9B,OAAKC,EAGE,CACL,SAAUA,EAAQ,CAAC,EACnB,cAAeA,EAAQ,CAAC,EAAI,SAASA,EAAQ,CAAC,CAAC,EAAI,MAAA,EAJ5C,IAMX,EAEaE,EAAe,CAC1BC,EACAC,IACQ,CACR,MAAMC,EAAc,CAAA,EACdC,EAAOF,EAAW,IAAIG,GAAOA,EAAI,MAAM,EACvCC,EAAUL,EAAc,IAAIM,GAAUA,EAAO,IAAI,EAClD,OAAAH,EAAA,QAAQ,CAACC,EAAKG,IAAU,CACpBL,EAAAK,CAAK,EAAI,GACZH,EAAA,QAAQ,CAACI,EAAMC,IAAc,CAC/BP,EAAOK,CAAK,EAAEF,EAAQI,CAAS,CAAC,EAAID,CAAA,CACrC,CAAA,CACF,EACMN,CACT"}