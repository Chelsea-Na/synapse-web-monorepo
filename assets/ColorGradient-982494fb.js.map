{"version":3,"file":"ColorGradient-982494fb.js","sources":["../../src/components/ColorGradient/ColorGradient.tsx"],"sourcesContent":["import {\n  COLOR_PALETTE_EVEN,\n  COLOR_PALETTE_ODD,\n} from '../../utils/functions/colorPalette'\n\nexport function rgba2rgb(background: number[], color: number[]) {\n  const alpha = color[3]\n  return [\n    Math.floor((1 - alpha) * background[0] + alpha * color[0] + 0.5),\n    Math.floor((1 - alpha) * background[1] + alpha * color[1] + 0.5),\n    Math.floor((1 - alpha) * background[2] + alpha * color[2] + 0.5),\n  ]\n}\n\nconst VARIANTS_PER_HUE = 5\nconst NUMBER_OF_HUES = Math.floor(COLOR_PALETTE_EVEN.length / VARIANTS_PER_HUE)\n\nexport function getColorPalette(\n  start: number,\n  end: number,\n): { colorPalette: string[]; textColors: string[] } {\n  let colorPaletteSelection: string[] = []\n  const textColors: string[] = []\n  let offset = -1\n\n  if (start % 2 === 0) {\n    colorPaletteSelection = COLOR_PALETTE_EVEN\n    offset = start * VARIANTS_PER_HUE\n  } else {\n    colorPaletteSelection = COLOR_PALETTE_ODD\n    offset = (start - 1) * VARIANTS_PER_HUE\n  }\n\n  const colorPalette: string[] = []\n\n  for (let i = 0; i < end; i++) {\n    // Each hue goes from dark to light, then light to dark, and repeats\n    // So we can use the index * 2 to determine if text shown should be white or black\n    const textColor: string =\n      i % (VARIANTS_PER_HUE * 2) < 2 || i % (VARIANTS_PER_HUE * 2) > 7\n        ? 'white'\n        : 'black'\n    const color: string =\n      colorPaletteSelection[(offset + i) % colorPaletteSelection.length]\n\n    colorPalette.push(color)\n    textColors.push(textColor)\n  }\n  return { colorPalette, textColors }\n}\n\nexport function getContrastColorPalette(\n  palette: 'even' | 'odd',\n  offset: number,\n  numberOfPalettes: number,\n): string[] {\n  let colorPaletteSelection: string[] = []\n\n  if (palette === 'even') {\n    colorPaletteSelection = COLOR_PALETTE_EVEN\n  } else {\n    colorPaletteSelection = COLOR_PALETTE_ODD\n  }\n  const colorPalette: string[] = []\n\n  for (let i = 0; i < numberOfPalettes; i++) {\n    // Each iteration should be a different hue\n    const hueIndex = i * VARIANTS_PER_HUE\n    // Select a lighter/darker variant using the offset\n    // if we happen to need more colors than we have hues, increment the offset (hence adding i / NUMBER_OF_HUES)\n    const hueOffset =\n      (offset + Math.floor(i / NUMBER_OF_HUES)) % VARIANTS_PER_HUE\n    const color: string =\n      colorPaletteSelection[\n        (hueIndex + hueOffset) % colorPaletteSelection.length\n      ]\n\n    colorPalette.push(color)\n  }\n  return colorPalette\n}\n"],"names":["VARIANTS_PER_HUE","NUMBER_OF_HUES","COLOR_PALETTE_EVEN","getColorPalette","start","end","colorPaletteSelection","textColors","offset","COLOR_PALETTE_ODD","colorPalette","i","textColor","color","getContrastColorPalette","palette","numberOfPalettes","hueIndex","hueOffset"],"mappings":"sDAcA,MAAMA,EAAmB,EACnBC,EAAiB,KAAK,MAAMC,EAAmB,OAASF,CAAgB,EAE9D,SAAAG,EACdC,EACAC,EACkD,CAClD,IAAIC,EAAkC,CAAA,EACtC,MAAMC,EAAuB,CAAA,EAC7B,IAAIC,EAAS,GAETJ,EAAQ,IAAM,GACQE,EAAAJ,EACxBM,EAASJ,EAAQJ,IAEOM,EAAAG,EACxBD,GAAUJ,EAAQ,GAAKJ,GAGzB,MAAMU,EAAyB,CAAA,EAE/B,QAASC,EAAI,EAAGA,EAAIN,EAAKM,IAAK,CAGtB,MAAAC,EACJD,GAAKX,EAAmB,GAAK,GAAKW,GAAKX,EAAmB,GAAK,EAC3D,QACA,QACAa,EACJP,GAAuBE,EAASG,GAAKL,EAAsB,MAAM,EAEnEI,EAAa,KAAKG,CAAK,EACvBN,EAAW,KAAKK,CAAS,CAC3B,CACO,MAAA,CAAE,aAAAF,EAAc,WAAAH,EACzB,CAEgB,SAAAO,EACdC,EACAP,EACAQ,EACU,CACV,IAAIV,EAAkC,CAAA,EAElCS,IAAY,OACUT,EAAAJ,EAEAI,EAAAG,EAE1B,MAAMC,EAAyB,CAAA,EAE/B,QAASC,EAAI,EAAGA,EAAIK,EAAkBL,IAAK,CAEzC,MAAMM,EAAWN,EAAIX,EAGfkB,GACHV,EAAS,KAAK,MAAMG,EAAIV,CAAc,GAAKD,EACxCa,EACJP,GACGW,EAAWC,GAAaZ,EAAsB,MACjD,EAEFI,EAAa,KAAKG,CAAK,CACzB,CACO,OAAAH,CACT"}