{"version":3,"file":"TableColumnSchemaEditor.stories-502bf6b5.js","sources":["../../../../node_modules/.pnpm/@mui+icons-material@5.13.7_@mui+material@5.13.7_@types+react@18.0.27_react@18.2.0/node_modules/@mui/icons-material/esm/North.js","../../../../node_modules/.pnpm/@mui+icons-material@5.13.7_@mui+material@5.13.7_@types+react@18.0.27_react@18.2.0/node_modules/@mui/icons-material/esm/South.js","../../../../node_modules/.pnpm/jotai@2.4.2_@types+react@18.0.27_react@18.2.0/node_modules/jotai/esm/vanilla/utils.mjs","../../src/components/TableColumnSchemaEditor/TableColumnSchemaEditorUtils.ts","../../src/components/TableColumnSchemaEditor/TableColumnSchemaFormReducer.ts","../../src/components/TableColumnSchemaEditor/ColumnModelForm.tsx","../../src/components/TableColumnSchemaEditor/TableColumnSchemaForm.tsx","../../src/components/TableColumnSchemaEditor/TableColumnSchemaEditor.tsx"],"sourcesContent":["import createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"m5 9 1.41 1.41L11 5.83V22h2V5.83l4.59 4.59L19 9l-7-7-7 7z\"\n}), 'North');","import createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"m19 15-1.41-1.41L13 18.17V2h-2v16.17l-4.59-4.59L5 15l7 7 7-7z\"\n}), 'South');","import { atom } from 'jotai/vanilla';\n\nconst RESET = Symbol();\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, action) => set(anAtom, reducer(get(anAtom), action))\n  );\n  return anAtom;\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove)\n      return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$4 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$4, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = atom((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        if (value instanceof Promise || prev instanceof Promise) {\n          return Promise.all([value, prev]).then(selectValue);\n        }\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo1$1 = (create, dep1) => (cache1$3.has(dep1) ? cache1$3 : cache1$3.set(dep1, create())).get(dep1);\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null)\n    return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  return memo1$1(() => {\n    const frozenAtom = atom(\n      (get) => deepFreeze(get(anAtom)),\n      (_get, set, arg) => set(anAtom, arg)\n    );\n    return frozenAtom;\n  }, anAtom);\n}\nfunction freezeAtomCreator(createAtom) {\n  return (...params) => {\n    const anAtom = createAtom(...params);\n    const origRead = anAtom.read;\n    anAtom.read = (get, options) => deepFreeze(origRead(get, options));\n    return anAtom;\n  };\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = atom((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? atom(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : atom((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        set(overwrittenAtom, EMPTY);\n      } else if (typeof update === \"function\") {\n        const prevValue = get(anAtom);\n        set(overwrittenAtom, update(prevValue));\n      } else {\n        set(overwrittenAtom, update);\n      }\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction createJSONStorage(getStringStorage) {\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2);\n          } catch {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a = getStringStorage()) == null ? void 0 : _a.getItem(key)) != null ? _b : null;\n      if (isPromiseLike(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.setItem(key, JSON.stringify(newValue));\n    },\n    removeItem: (key) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.removeItem(key);\n    }\n  };\n  if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    storage.subscribe = (key, callback, initialValue) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          let newValue;\n          try {\n            newValue = JSON.parse(e.newValue || \"\");\n          } catch {\n            newValue = initialValue;\n          }\n          callback(newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage(\n  () => typeof window !== \"undefined\" ? window.localStorage : void 0\n);\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, unstable_options) {\n  const getOnInit = unstable_options == null ? void 0 : unstable_options.unstable_getOnInit;\n  const baseAtom = atom(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    if (!getOnInit) {\n      setAtom(storage.getItem(key, initialValue));\n    }\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (nextValue instanceof Promise) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (result instanceof Promise) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!(value instanceof Promise)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached = loadableCache.get(promise);\n        if (cached) {\n          return cached;\n        }\n        loadableCache.set(promise, LOADING);\n        promise.then(\n          (data) => {\n            loadableCache.set(promise, { state: \"hasData\", data });\n          },\n          (error) => {\n            loadableCache.set(promise, { state: \"hasError\", error });\n          }\n        ).finally(setSelf);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = atom(0);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = atom(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!(promise instanceof Promise)) {\n            return { v: promise };\n          }\n          if (promise === (prev == null ? void 0 : prev.p)) {\n            if (promiseErrorCache.has(promise)) {\n              throw promiseErrorCache.get(promise);\n            }\n            if (promiseResultCache.has(promise)) {\n              return {\n                p: promise,\n                v: promiseResultCache.get(promise)\n              };\n            }\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            promise.then(\n              (v) => promiseResultCache.set(promise, v),\n              (e) => promiseErrorCache.set(promise, e)\n            ).finally(setSelf);\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v) };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return atom(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"v\" in state) {\n            return state.v;\n          }\n          return state.f;\n        },\n        anAtom.write\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithObservable, atomWithReducer, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, unwrap };\n","import {\n  ColumnType,\n  ColumnTypeEnum,\n  FacetType,\n} from '@sage-bionetworks/synapse-types'\n\n/**\n * These column types can only be used in Tables. They can not be used in views.\n *  See SWC-6333 - for views, only allow column types that are mapped to annotation types.\n */\nconst unsupportedTypesForViews = [\n  ColumnTypeEnum.LARGETEXT,\n  ColumnTypeEnum.MEDIUMTEXT,\n  ColumnTypeEnum.JSON,\n]\nexport function getAllowedColumnTypes(\n  isView: boolean,\n  isJsonSubColumnFacet: boolean,\n) {\n  return Object.values(ColumnTypeEnum)\n    .filter(columnType =>\n      isView ? !unsupportedTypesForViews.includes(columnType) : true,\n    )\n    .filter(columnType => {\n      if (isJsonSubColumnFacet) {\n        switch (columnType) {\n          // JSON Subcolumns cannot be JSON or LIST types\n          case ColumnTypeEnum.JSON:\n          case ColumnTypeEnum.STRING_LIST:\n          case ColumnTypeEnum.INTEGER_LIST:\n          case ColumnTypeEnum.BOOLEAN_LIST:\n          case ColumnTypeEnum.DATE_LIST:\n          case ColumnTypeEnum.USERID_LIST:\n          case ColumnTypeEnum.ENTITYID_LIST:\n            return false\n          default:\n            return true\n        }\n      }\n      return true\n    })\n}\n\nexport function getFacetTypeFriendlyName(facetType: FacetType) {\n  switch (facetType) {\n    case 'enumeration':\n      return 'Values'\n    case 'range':\n      return 'Range'\n    default:\n      return facetType\n  }\n}\nexport function getColumnTypeFriendlyName(type: ColumnType | ColumnTypeEnum) {\n  switch (type) {\n    case ColumnTypeEnum.STRING:\n      return 'String'\n    case ColumnTypeEnum.DOUBLE:\n      return 'Double'\n    case ColumnTypeEnum.BOOLEAN:\n      return 'Boolean'\n    case ColumnTypeEnum.INTEGER:\n      return 'Integer'\n    case ColumnTypeEnum.DATE:\n      return 'Date'\n    case ColumnTypeEnum.FILEHANDLEID:\n      return 'File'\n    case ColumnTypeEnum.ENTITYID:\n      return 'Entity'\n    case ColumnTypeEnum.LINK:\n      return 'Link'\n    case ColumnTypeEnum.MEDIUMTEXT:\n      return 'MediumText'\n    case ColumnTypeEnum.LARGETEXT:\n      return 'LargeText'\n    case ColumnTypeEnum.USERID:\n      return 'User'\n    case ColumnTypeEnum.STRING_LIST:\n      return 'String List'\n    case ColumnTypeEnum.INTEGER_LIST:\n      return 'Integer List'\n    case ColumnTypeEnum.BOOLEAN_LIST:\n      return 'Boolean List'\n    case ColumnTypeEnum.DATE_LIST:\n      return 'Date List'\n    case ColumnTypeEnum.USERID_LIST:\n      return 'User ID List'\n    case ColumnTypeEnum.ENTITYID_LIST:\n      return 'Entity ID List'\n    case ColumnTypeEnum.EVALUATIONID:\n      return 'Evaluation'\n    case ColumnTypeEnum.JSON:\n      return 'JSON'\n    default:\n      return type\n  }\n}\n\n/**\n * Can the given type have a size?\n *\n * @param type\n * @return\n */\nexport function canHaveSize(type: ColumnType | ColumnTypeEnum): boolean {\n  switch (type) {\n    case ColumnTypeEnum.STRING:\n    case ColumnTypeEnum.STRING_LIST:\n    case ColumnTypeEnum.LINK:\n      return true\n    default:\n      // all others are false\n      return false\n  }\n}\n\nexport function canHaveMaxListLength(\n  type: ColumnType | ColumnTypeEnum,\n): boolean {\n  switch (type) {\n    case ColumnTypeEnum.STRING_LIST:\n    case ColumnTypeEnum.BOOLEAN_LIST:\n    case ColumnTypeEnum.DATE_LIST:\n    case ColumnTypeEnum.INTEGER_LIST:\n      return true\n    default:\n      // all others are false\n      return false\n  }\n}\n\n/**\n * Configure the facet selection based on the column type\n *\n * @param type a ColumnType for which to get the facet selection\n * @param isJsonSubColumnFacet is this a facet for a json subcolumn?\n * @return the allowed facetTypes, or null if faceting is not allowed\n */\nexport function configureFacetsForType(\n  type: ColumnType | ColumnTypeEnum,\n  isJsonSubColumnFacet: boolean,\n): (FacetType | undefined)[] | null {\n  let allowedFacetTypes: (FacetType | undefined)[] | null\n  switch (type) {\n    case ColumnTypeEnum.INTEGER:\n    case ColumnTypeEnum.INTEGER_LIST:\n      allowedFacetTypes = ['enumeration', 'range']\n      break\n    case ColumnTypeEnum.STRING:\n    case ColumnTypeEnum.BOOLEAN:\n    case ColumnTypeEnum.USERID:\n    case ColumnTypeEnum.ENTITYID:\n    case ColumnTypeEnum.STRING_LIST:\n    case ColumnTypeEnum.BOOLEAN_LIST:\n    case ColumnTypeEnum.ENTITYID_LIST:\n    case ColumnTypeEnum.USERID_LIST:\n    case ColumnTypeEnum.EVALUATIONID:\n      allowedFacetTypes = ['enumeration']\n      break\n    case ColumnTypeEnum.DOUBLE:\n    case ColumnTypeEnum.DATE:\n    case ColumnTypeEnum.DATE_LIST:\n      allowedFacetTypes = ['range']\n      break\n    default:\n      allowedFacetTypes = null\n  }\n\n  if (allowedFacetTypes && !isJsonSubColumnFacet) {\n    // jsonSubColumn facets MUST have a facet definition, but regular column models do not need one\n    // So allow `undefined` for regular columnModels.\n    allowedFacetTypes = [undefined, ...allowedFacetTypes]\n  }\n  return allowedFacetTypes\n}\n\nexport function canHaveDefault(\n  type: ColumnType | ColumnTypeEnum,\n  isView: boolean,\n  isJsonSubColumnFacet: boolean,\n) {\n  // SWC-6333: default types are not allowed in views\n  if (!isView && !isJsonSubColumnFacet) {\n    switch (type) {\n      case ColumnTypeEnum.ENTITYID:\n      case ColumnTypeEnum.FILEHANDLEID:\n      case ColumnTypeEnum.USERID:\n      case ColumnTypeEnum.MEDIUMTEXT:\n      case ColumnTypeEnum.LARGETEXT:\n      case ColumnTypeEnum.JSON:\n        return false\n      default:\n        return true\n    }\n  } else {\n    return false\n  }\n}\n\nconst DEFAULT_STRING_SIZE = 50\nconst MAX_STRING_SIZE = 1000\n\n/**\n * Get the default max size for a given type.\n *\n * @param type\n * @return\n */\nexport function getMaxSizeForType(type: ColumnType | ColumnTypeEnum): number {\n  switch (type) {\n    case ColumnTypeEnum.STRING:\n    case ColumnTypeEnum.STRING_LIST:\n      return DEFAULT_STRING_SIZE\n    case ColumnTypeEnum.LINK:\n      return MAX_STRING_SIZE\n    default:\n      throw new Error(`Type is not known to have a max size: ${type}`)\n  }\n}\n\nexport function canHaveRestrictedValues(\n  type: ColumnType | ColumnTypeEnum,\n  isJsonSubColumnFacet: boolean,\n): boolean {\n  if (isJsonSubColumnFacet) {\n    return false\n  }\n  switch (type) {\n    case ColumnTypeEnum.STRING:\n    case ColumnTypeEnum.INTEGER:\n    case ColumnTypeEnum.ENTITYID:\n      return true\n    default:\n      // all other are false\n      return false\n  }\n}\n","import {\n  ColumnModel,\n  ColumnTypeEnum,\n  JsonSubColumnModel,\n} from '@sage-bionetworks/synapse-types'\nimport { atomWithReducer } from 'jotai/utils'\nimport { SetOptional } from 'type-fest'\nimport { cloneDeep } from 'lodash-es'\nimport {\n  canHaveMaxListLength,\n  canHaveRestrictedValues,\n  canHaveSize,\n  configureFacetsForType,\n} from './TableColumnSchemaEditorUtils'\n\nexport function getIsAllSelected(formData: ColumnModelFormData[]) {\n  return (\n    formData.length > 0 &&\n    formData.every(\n      cm =>\n        // Is selected\n        cm.isSelected &&\n        // And all subcolumns are selected (true if there are no subcolumns)\n        (cm.jsonSubColumns ?? []).every(\n          (jsc: JsonSubColumnModelFormData) => jsc.isSelected,\n        ),\n    )\n  )\n}\n\nexport function getNumberOfSelectedItems(formData: ColumnModelFormData[]) {\n  return formData.reduce((acc, curr) => {\n    if (curr.isSelected) {\n      acc += 1\n    }\n    if (curr.jsonSubColumns) {\n      curr.jsonSubColumns.forEach((jsc: JsonSubColumnModelFormData) => {\n        if (jsc.isSelected) {\n          acc += 1\n        }\n      })\n    }\n    return acc\n  }, 0)\n}\n\nexport function getDefaultColumnModelFormData(): ColumnModelFormData {\n  return {\n    id: '',\n    name: '',\n    columnType: ColumnTypeEnum.STRING,\n    isSelected: false,\n  }\n}\n\nexport function getDefaultJsonSubColumnFormData(): JsonSubColumnModelFormData {\n  return {\n    name: '',\n    jsonPath: '',\n    columnType: ColumnTypeEnum.STRING,\n    facetType: 'enumeration',\n    isSelected: false,\n  }\n}\n\n/**\n * In the provided array, move items up where the predicate evaluates to true\n * @param arr the array to reorder\n * @param predicate a function that returns true if the item should be moved up\n * @returns - a new array with the reordered items\n */\nfunction moveSelectedItemsUp<T = unknown>(\n  arr: T[],\n  predicate: (item: T) => boolean,\n) {\n  const newArr = [...arr]\n  newArr.forEach((item, index) => {\n    // For each item that should move up, swap it with the previous item\n    if (\n      // Cannot move index 0 up\n      index > 0 &&\n      // Only move if the predicate matches\n      predicate(item) &&\n      // If the previous item should also move, skip the swap\n      !predicate(newArr[index - 1])\n    ) {\n      // swap the items\n      const temp = newArr[index - 1]\n      newArr[index - 1] = newArr[index]\n      newArr[index] = temp\n    }\n  })\n  return newArr\n}\n\n/**\n * In the provided array, move items down where the predicate evaluates to true\n * @param arr the array to reorder\n * @param predicate a function that returns true if the item should be moved down\n * @returns - a new array with the reordered items\n */\nfunction moveSelectedItemsDown<T = unknown>(\n  arr: T[],\n  predicate: (item: T) => boolean,\n) {\n  const newArr = [...arr]\n  // Start from the end and work backwards, otherwise items could be moved more than once\n  for (let i = newArr.length - 1; i >= 0; i--) {\n    const item = newArr[i]\n    if (\n      // Cannot move the last item down\n      i < newArr.length - 1 &&\n      // Only move if the predicate matches\n      predicate(item) &&\n      // If the next item should also be moved, don't swap\n      !predicate(newArr[i + 1])\n    ) {\n      // swap the items\n      const temp = newArr[i]\n      newArr[i] = newArr[i + 1]\n      newArr[i + 1] = temp\n    }\n  }\n  return newArr\n}\n\nexport type JsonSubColumnModelFormData = JsonSubColumnModel & {\n  // add `isSelected` to the data object\n  isSelected: boolean\n}\n\nexport type ColumnModelFormData = Omit<\n  SetOptional<ColumnModel, 'id'>,\n  'jsonSubColumns'\n> & {\n  // add `isSelected` to the data object\n  isSelected: boolean\n  // jsonSubColumns will also include formData (like isSelected)\n  jsonSubColumns?: JsonSubColumnModelFormData[]\n}\n\ntype TableColumnSchemaFormReducerAction =\n  | {\n      type: 'setValue'\n      value: ColumnModelFormData[]\n    }\n  | {\n      type: 'toggleSelect'\n      columnModelIndex: number\n      jsonSubColumnModelIndex?: number\n    }\n  | { type: 'toggleSelectAll' }\n  | {\n      type: 'appendColumn'\n    }\n  | {\n      type: 'appendJsonSubColumn'\n      columnModelIndex: number\n    }\n  | {\n      type: 'setColumnModelValue'\n      columnModelIndex: number\n      jsonSubColumnModelIndex?: number\n      value: ColumnModelFormData | JsonSubColumnModelFormData\n    }\n  | {\n      type: 'changeColumnModelType'\n      newColumnType: ColumnTypeEnum\n      columnModelIndex: number\n      jsonSubColumnModelIndex?: number\n    }\n  | {\n      type: 'move'\n      from: {\n        columnModelIndex: number\n        jsonSubColumnModelIndex?: number\n      }\n      to: { columnModelIndex: number; jsonSubColumnModelIndex?: number }\n    }\n  | {\n      type: 'moveUp'\n    }\n  | {\n      type: 'moveDown'\n    }\n  | {\n      type: 'delete'\n    }\n\nfunction changeColumnModelType(\n  action: {\n    type: 'changeColumnModelType'\n    newColumnType: ColumnTypeEnum\n    columnModelIndex: number\n    jsonSubColumnModelIndex?: number\n  },\n  prevState: ColumnModelFormData[],\n) {\n  const { columnModelIndex, jsonSubColumnModelIndex, newColumnType } = action\n  let newColumnModelValue: ColumnModelFormData | JsonSubColumnModelFormData\n\n  // Create a copy of the selected column model\n  if (prevState && prevState[columnModelIndex]) {\n    if (\n      prevState[columnModelIndex].jsonSubColumns &&\n      jsonSubColumnModelIndex !== undefined\n    ) {\n      newColumnModelValue = cloneDeep(\n        prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex],\n      )\n    } else {\n      newColumnModelValue = cloneDeep(prevState[columnModelIndex])\n    }\n  } else {\n    throw new Error(\n      'Cannot change column model type for a column that does not exist',\n    )\n  }\n\n  // Update the column model. Remove fields that no longer make sense for the new column type\n  newColumnModelValue.columnType = newColumnType\n  if (!canHaveSize(newColumnType) && 'maximumSize' in newColumnModelValue) {\n    delete newColumnModelValue.maximumSize\n  }\n  if (\n    !canHaveMaxListLength(newColumnType) &&\n    'maximumListLength' in newColumnModelValue\n  ) {\n    delete newColumnModelValue.maximumListLength\n  }\n  if (\n    !canHaveRestrictedValues(newColumnType, !!jsonSubColumnModelIndex) &&\n    'enumValues' in newColumnModelValue\n  ) {\n    delete newColumnModelValue.enumValues\n  }\n\n  const allowedFacetTypes = configureFacetsForType(\n    newColumnType,\n    !!jsonSubColumnModelIndex,\n  )\n  if (\n    'facetType' in newColumnModelValue &&\n    (allowedFacetTypes === null ||\n      !allowedFacetTypes.includes(newColumnModelValue.facetType))\n  ) {\n    delete newColumnModelValue.facetType\n  }\n\n  if (\n    'jsonSubColumns' in newColumnModelValue &&\n    newColumnType !== ColumnTypeEnum.JSON\n  ) {\n    delete newColumnModelValue.jsonSubColumns\n  }\n\n  // Replace the value\n  if (prevState && prevState[columnModelIndex]) {\n    if (\n      prevState[columnModelIndex].jsonSubColumns &&\n      jsonSubColumnModelIndex !== undefined\n    ) {\n      prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex] =\n        newColumnModelValue as JsonSubColumnModelFormData\n    } else {\n      prevState[columnModelIndex] = newColumnModelValue as ColumnModelFormData\n    }\n  }\n}\n\nfunction toggleSelectAll(prevState: ColumnModelFormData[]) {\n  const allSelected = getIsAllSelected(prevState)\n  if (allSelected) {\n    return prevState.map(cm => ({\n      ...cm,\n      jsonSubColumns: cm.jsonSubColumns?.map(jsc => ({\n        ...jsc,\n        isSelected: false,\n      })),\n      isSelected: false,\n    }))\n  } else {\n    return prevState.map(cm => ({\n      ...cm,\n      jsonSubColumns: cm.jsonSubColumns?.map(jsc => ({\n        ...jsc,\n        isSelected: true,\n      })),\n      isSelected: true,\n    }))\n  }\n}\n\nfunction setColumnModelValue(\n  action: {\n    type: 'setColumnModelValue'\n    columnModelIndex: number\n    jsonSubColumnModelIndex?: number\n    value: ColumnModelFormData | JsonSubColumnModelFormData\n  },\n  prevState: ColumnModelFormData[],\n) {\n  const { columnModelIndex, jsonSubColumnModelIndex, value } = action\n  if (prevState && prevState[columnModelIndex]) {\n    if (\n      prevState[columnModelIndex].jsonSubColumns &&\n      jsonSubColumnModelIndex !== undefined\n    ) {\n      prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex] =\n        value as JsonSubColumnModelFormData\n    } else {\n      prevState[columnModelIndex] = value as ColumnModelFormData\n    }\n  }\n}\n\nfunction toggleSelect(\n  action: {\n    type: 'toggleSelect'\n    columnModelIndex: number\n    jsonSubColumnModelIndex?: number\n  },\n  prevState: ColumnModelFormData[],\n) {\n  const { columnModelIndex, jsonSubColumnModelIndex } = action\n  if (prevState && prevState[columnModelIndex]) {\n    if (\n      prevState[columnModelIndex].jsonSubColumns &&\n      jsonSubColumnModelIndex !== undefined\n    ) {\n      const cm =\n        prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex]\n      prevState[columnModelIndex].jsonSubColumns![jsonSubColumnModelIndex] = {\n        ...cm,\n        isSelected: !cm.isSelected,\n      }\n    } else {\n      const cm = prevState[columnModelIndex]\n      prevState[columnModelIndex] = { ...cm, isSelected: !cm.isSelected }\n    }\n  }\n}\n\nfunction deleteColumnModel(prevState: ColumnModelFormData[]) {\n  return prevState\n    .filter(cm => !cm.isSelected)\n    .map(cm => {\n      if (cm.jsonSubColumns) {\n        cm = {\n          ...cm,\n          jsonSubColumns: cm.jsonSubColumns.filter(\n            (jsc: JsonSubColumnModelFormData) => !jsc.isSelected,\n          ),\n        }\n      }\n      return cm\n    })\n}\n\n/**\n * Returns a new, shallowly-cloned array that moves the object from the `fromIndex` to the `toIndex`.\n * Derived from https://stackoverflow.com/a/6470794/9723359\n *\n * Returns the same array if the `fromIndex` and `toIndex` are the same.\n * @param arrayToReorder\n * @param fromIndex\n * @param toIndex\n */\nfunction moveElementInArray<T = unknown>(\n  arrayToReorder: Array<T>,\n  fromIndex: number,\n  toIndex: number,\n): Array<T> {\n  if (fromIndex == toIndex) {\n    return arrayToReorder\n  }\n  const newArray = [...arrayToReorder]\n  const elementToMove = newArray[fromIndex]\n  newArray.splice(fromIndex, 1)\n  newArray.splice(toIndex, 0, elementToMove)\n  return newArray\n}\n\n/**\n * Moves a column model or jsonSubColumn from the `from` index to the `to` index\n * @param action\n * @param prevState\n */\nfunction moveColumnModel(\n  action: {\n    type: 'move'\n    from: { columnModelIndex: number; jsonSubColumnModelIndex?: number }\n    to: { columnModelIndex: number; jsonSubColumnModelIndex?: number }\n  },\n  prevState: ColumnModelFormData[],\n) {\n  const { from, to } = action\n  const arrayToReorder =\n    from.jsonSubColumnModelIndex !== undefined\n      ? prevState[from.columnModelIndex].jsonSubColumns!\n      : prevState\n\n  const fromIndex =\n    from.jsonSubColumnModelIndex !== undefined\n      ? from.jsonSubColumnModelIndex\n      : from.columnModelIndex\n\n  const toIndex =\n    to.jsonSubColumnModelIndex !== undefined\n      ? to.jsonSubColumnModelIndex\n      : to.columnModelIndex\n\n  // Move the element\n  const newArray = moveElementInArray(arrayToReorder, fromIndex, toIndex)\n\n  if (from.jsonSubColumnModelIndex !== undefined) {\n    // If we moved a jsonSubColumn, update state to use the new, reordered array\n    prevState[from.columnModelIndex].jsonSubColumns =\n      newArray as JsonSubColumnModelFormData[]\n    return prevState\n  } else {\n    // Otherwise, return the new, reordered array of column models\n    return newArray\n  }\n}\n\nexport function reducer(\n  prevState: ColumnModelFormData[],\n  action: TableColumnSchemaFormReducerAction,\n) {\n  switch (action.type) {\n    case 'setValue':\n      prevState = action.value\n      break\n    case 'toggleSelectAll': {\n      prevState = toggleSelectAll(prevState)\n      break\n    }\n    case 'setColumnModelValue': {\n      setColumnModelValue(action, prevState)\n      break\n    }\n    case 'changeColumnModelType': {\n      changeColumnModelType(action, prevState)\n      break\n    }\n\n    case 'appendColumn':\n      prevState.push(getDefaultColumnModelFormData())\n      break\n    case 'appendJsonSubColumn': {\n      const { columnModelIndex } = action\n      prevState[columnModelIndex] = {\n        ...prevState[columnModelIndex],\n        jsonSubColumns: [\n          ...(prevState[columnModelIndex].jsonSubColumns ?? []),\n          getDefaultJsonSubColumnFormData(),\n        ],\n      }\n      break\n    }\n    case 'toggleSelect': {\n      toggleSelect(action, prevState)\n      break\n    }\n    case 'delete':\n      prevState = deleteColumnModel(prevState)\n      break\n    case 'move': {\n      prevState = moveColumnModel(action, prevState)\n      break\n    }\n    case 'moveUp':\n      prevState = moveSelectedItemsUp(prevState, cm => cm.isSelected)\n      prevState.forEach(cm => {\n        if (cm.jsonSubColumns) {\n          cm.jsonSubColumns = moveSelectedItemsUp(\n            cm.jsonSubColumns,\n            jsc => jsc.isSelected,\n          )\n        }\n      })\n      break\n    case 'moveDown':\n      prevState = moveSelectedItemsDown(prevState, cm => cm.isSelected)\n      prevState.forEach(cm => {\n        if (cm.jsonSubColumns) {\n          cm.jsonSubColumns = moveSelectedItemsDown(\n            cm.jsonSubColumns,\n            jsc => jsc.isSelected,\n          )\n        }\n      })\n      break\n    default:\n      throw new Error(`Unexpected action`, action)\n  }\n  return [...prevState]\n}\n\nexport const tableColumnSchemaFormDataAtom = atomWithReducer<\n  ColumnModelFormData[],\n  TableColumnSchemaFormReducerAction\n>([], reducer)\n","import {\n  Box,\n  FormControl,\n  Link,\n  MenuItem,\n  Select,\n  SxProps,\n  TextField,\n  Tooltip,\n} from '@mui/material'\nimport { useAtomValue, useSetAtom } from 'jotai'\nimport { selectAtom } from 'jotai/utils'\nimport {\n  ColumnModelFormData,\n  JsonSubColumnModelFormData,\n  tableColumnSchemaFormDataAtom,\n} from './TableColumnSchemaFormReducer'\nimport {\n  ColumnTypeEnum,\n  EntityType,\n  FacetType,\n  VIEW_CONCRETE_TYPE_VALUES,\n} from '@sage-bionetworks/synapse-types'\nimport { convertToConcreteEntityType } from '../../utils/functions/EntityTypeUtils'\nimport React, { useMemo, useState } from 'react'\nimport { isEmpty, isEqual } from 'lodash-es'\nimport {\n  canHaveDefault,\n  canHaveMaxListLength,\n  canHaveRestrictedValues,\n  canHaveSize,\n  configureFacetsForType,\n  getAllowedColumnTypes,\n  getColumnTypeFriendlyName,\n  getFacetTypeFriendlyName,\n  getMaxSizeForType,\n} from './TableColumnSchemaEditorUtils'\nimport { Checkbox } from '../widgets/Checkbox'\nimport JSONArrayEditorModal from '../JSONArrayEditor/JSONArrayEditorModal'\nimport { HIERARCHY_VERTICAL_LINE_COMPONENT } from './TableColumnSchemaForm'\nimport { InfoTwoTone } from '@mui/icons-material'\n\ntype ColumnOrSubcolumnFormProps = {\n  entityType: EntityType\n  columnModelIndex: number\n  jsonSubColumnIndex?: number\n}\nconst jsonSubColumnFieldSx: SxProps = {\n  height: '28px',\n  fontSize: '12px',\n}\nconst topLevelColumnModelFieldSx: SxProps = {\n  height: '38px',\n  fontSize: '14px',\n}\n\nexport default function ColumnModelForm(props: ColumnOrSubcolumnFormProps) {\n  const { columnModelIndex, jsonSubColumnIndex, entityType } = props\n  const isJsonSubColumn = jsonSubColumnIndex != undefined\n  const dispatch = useSetAtom(tableColumnSchemaFormDataAtom)\n  const isView = (VIEW_CONCRETE_TYPE_VALUES as readonly string[]).includes(\n    convertToConcreteEntityType(entityType),\n  )\n\n  const [isShowingRestrictedValuesModal, setIsShowingRestrictedValuesModal] =\n    useState(false)\n\n  const columnModelAtom = useMemo(\n    () =>\n      selectAtom(\n        tableColumnSchemaFormDataAtom,\n        v =>\n          isJsonSubColumn\n            ? v[columnModelIndex].jsonSubColumns![jsonSubColumnIndex]\n            : v[columnModelIndex],\n        isEqual,\n      ),\n    [columnModelIndex, isJsonSubColumn, jsonSubColumnIndex],\n  )\n\n  const columnModel = useAtomValue(columnModelAtom)\n\n  const allowedColumnTypes = useMemo(\n    () => getAllowedColumnTypes(isView, isJsonSubColumn),\n    [isView, isJsonSubColumn],\n  )\n\n  const allowedFacetTypes = useMemo(\n    () => configureFacetsForType(columnModel.columnType, isJsonSubColumn),\n    [columnModel.columnType, isJsonSubColumn],\n  )\n  const fieldSx: SxProps = useMemo(\n    () => (isJsonSubColumn ? jsonSubColumnFieldSx : topLevelColumnModelFieldSx),\n    [isJsonSubColumn],\n  )\n\n  return (\n    <>\n      {isJsonSubColumn && (\n        <Box sx={{ gridColumn: '1 / span 1' }}>\n          {HIERARCHY_VERTICAL_LINE_COMPONENT}\n        </Box>\n      )}\n      <Box\n        display={'flex'}\n        alignItems={'center'}\n        sx={{\n          gridColumn: isJsonSubColumn ? '2 / span 1' : ' 1 / span 1',\n        }}\n      >\n        <Checkbox\n          label={'Select'}\n          hideLabel\n          checked={columnModel.isSelected}\n          onChange={() => {\n            dispatch({\n              type: 'toggleSelect',\n              columnModelIndex,\n              jsonSubColumnModelIndex: jsonSubColumnIndex,\n            })\n          }}\n        />\n      </Box>\n      <Box\n        sx={{\n          gridColumn: isJsonSubColumn\n            ? /* If this is a JSON Subcolumn, we reduce the width of this grid column to create space to render the visual hierarchical line */\n              '3 / span 1'\n            : /* Otherwise, span across both grid columns  */\n              '2 / span 2',\n        }}\n      >\n        <TextField\n          value={columnModel.name}\n          placeholder={isJsonSubColumn ? 'Facet name' : 'Column name'}\n          onChange={e => {\n            dispatch({\n              type: 'setColumnModelValue',\n              columnModelIndex,\n              jsonSubColumnModelIndex: jsonSubColumnIndex,\n              value: {\n                ...columnModel,\n                name: e.target.value,\n              },\n            })\n          }}\n          InputProps={{\n            sx: fieldSx,\n            inputProps: {\n              'aria-label': 'Name',\n            },\n          }}\n          fullWidth\n        />\n      </Box>\n      <Box>\n        <FormControl fullWidth>\n          <Select\n            label=\"Column Type\"\n            value={columnModel.columnType}\n            onChange={e => {\n              dispatch({\n                type: 'changeColumnModelType',\n                columnModelIndex,\n                jsonSubColumnModelIndex: jsonSubColumnIndex,\n                newColumnType: e.target.value as ColumnTypeEnum,\n              })\n            }}\n            sx={fieldSx}\n          >\n            {allowedColumnTypes.map(value => {\n              return (\n                <MenuItem value={value} key={value}>\n                  {getColumnTypeFriendlyName(value)}\n                </MenuItem>\n              )\n            })}\n          </Select>\n        </FormControl>\n      </Box>\n      <Box>\n        <TextField\n          type={'number'}\n          value={(columnModel as ColumnModelFormData).maximumSize ?? ''}\n          disabled={!canHaveSize(columnModel.columnType)}\n          InputProps={{\n            inputProps: {\n              'aria-label': 'Maximum Size',\n              min: 0,\n              max: canHaveSize(columnModel.columnType)\n                ? getMaxSizeForType(columnModel.columnType)\n                : undefined,\n            },\n            sx: fieldSx,\n          }}\n          onChange={e => {\n            dispatch({\n              type: 'setColumnModelValue',\n              columnModelIndex,\n              jsonSubColumnModelIndex: jsonSubColumnIndex,\n              value: {\n                ...columnModel,\n                maximumSize: parseInt(e.target.value),\n              },\n            })\n          }}\n          fullWidth\n        />\n      </Box>\n      <Box>\n        <TextField\n          type={'number'}\n          value={(columnModel as ColumnModelFormData).maximumListLength ?? ''}\n          disabled={!canHaveMaxListLength(columnModel.columnType)}\n          onChange={e => {\n            dispatch({\n              type: 'setColumnModelValue',\n              columnModelIndex,\n              jsonSubColumnModelIndex: jsonSubColumnIndex,\n              value: {\n                ...columnModel,\n                maximumListLength: parseInt(e.target.value),\n              },\n            })\n          }}\n          InputProps={{\n            inputProps: {\n              'aria-label': 'Maximum List Length',\n            },\n            sx: fieldSx,\n          }}\n          fullWidth\n        />\n      </Box>\n      <Box>\n        <TextField\n          fullWidth\n          value={(columnModel as ColumnModelFormData)?.defaultValue ?? ''}\n          disabled={\n            !canHaveDefault(columnModel.columnType, isView, isJsonSubColumn)\n          }\n          onChange={e => {\n            dispatch({\n              type: 'setColumnModelValue',\n              columnModelIndex,\n              jsonSubColumnModelIndex: jsonSubColumnIndex,\n              value: {\n                ...columnModel,\n                defaultValue: e.target.value,\n              },\n            })\n          }}\n          InputProps={{\n            inputProps: {\n              'aria-label': 'Default Value',\n            },\n            sx: fieldSx,\n          }}\n        />\n      </Box>\n      <Box>\n        <JSONArrayEditorModal\n          isShowingModal={isShowingRestrictedValuesModal}\n          onConfirm={newValue => {\n            dispatch({\n              type: 'setColumnModelValue',\n              columnModelIndex,\n              jsonSubColumnModelIndex: jsonSubColumnIndex,\n              value: {\n                ...columnModel,\n                enumValues: isEmpty(newValue) ? undefined : newValue,\n              },\n            })\n            setIsShowingRestrictedValuesModal(false)\n          }}\n          onCancel={() => setIsShowingRestrictedValuesModal(false)}\n        />\n        <TextField\n          fullWidth\n          value={((columnModel as ColumnModelFormData)?.enumValues ?? []).join(\n            ', ',\n          )}\n          onClick={() => {\n            setIsShowingRestrictedValuesModal(true)\n          }}\n          disabled={canHaveRestrictedValues(\n            columnModel.columnType,\n            isJsonSubColumn,\n          )}\n          InputProps={{\n            // Is readOnly because edits are made with the JSONArrayEditorModal\n            readOnly: true,\n            sx: fieldSx,\n            inputProps: {\n              'aria-label': 'Restrict Values',\n            },\n          }}\n        />\n      </Box>\n      <Box>\n        <FormControl fullWidth>\n          <Select\n            label=\"Facet Type\"\n            value={columnModel.facetType}\n            disabled={allowedFacetTypes === null}\n            onChange={e => {\n              dispatch({\n                type: 'setColumnModelValue',\n                columnModelIndex,\n                jsonSubColumnModelIndex: jsonSubColumnIndex,\n                value: {\n                  ...columnModel,\n                  facetType: e.target.value as FacetType,\n                },\n              })\n            }}\n            sx={fieldSx}\n          >\n            {(allowedFacetTypes ?? []).map((value, index) => {\n              return (\n                <MenuItem value={value} key={index}>\n                  {value === undefined ? '' : getFacetTypeFriendlyName(value)}\n                </MenuItem>\n              )\n            })}\n          </Select>\n        </FormControl>\n      </Box>\n      {isJsonSubColumn && (\n        <>\n          <Box>{HIERARCHY_VERTICAL_LINE_COMPONENT}</Box>\n          <Box></Box>\n          <Box\n            sx={{\n              gridColumn: '3 / span 7',\n            }}\n          >\n            <TextField\n              placeholder={'JSON Path'}\n              value={(columnModel as JsonSubColumnModelFormData).jsonPath}\n              onChange={e => {\n                dispatch({\n                  type: 'setColumnModelValue',\n                  columnModelIndex,\n                  jsonSubColumnModelIndex: jsonSubColumnIndex,\n                  value: {\n                    ...(columnModel as JsonSubColumnModelFormData),\n                    jsonPath: e.target.value,\n                  },\n                })\n              }}\n              fullWidth\n              InputProps={{\n                sx: fieldSx,\n                endAdornment: (\n                  <Tooltip\n                    title={\n                      <React.Fragment>\n                        <p>\n                          <Link\n                            href={\n                              'https://dev.mysql.com/doc/refman/8.0/en/json.html#json-path-syntax'\n                            }\n                          >\n                            Please use a valid JSON Path selector, following\n                            this format.\n                          </Link>\n                        </p>\n                        <p>\n                          This field is for linking the sub-column facet to the\n                          corresponding location in the JSON data, so that it\n                          can be used as facet filter. The correct selector will\n                          point to the key referenced in the sub-column JSON\n                          Path.\n                        </p>\n                      </React.Fragment>\n                    }\n                  >\n                    <InfoTwoTone sx={{ color: 'grey.700' }} />\n                  </Tooltip>\n                ),\n                inputProps: {\n                  'aria-label': 'JSON Path',\n                },\n              }}\n            />\n          </Box>\n        </>\n      )}\n    </>\n  )\n}\n","import {\n  ColumnModel,\n  ColumnTypeEnum,\n  EntityType,\n  JsonSubColumnModel,\n} from '@sage-bionetworks/synapse-types'\nimport { atom, useAtomValue, useSetAtom } from 'jotai'\nimport React, { useEffect, useMemo } from 'react'\nimport {\n  ColumnModelFormData,\n  getIsAllSelected,\n  getNumberOfSelectedItems,\n  JsonSubColumnModelFormData,\n  tableColumnSchemaFormDataAtom,\n} from './TableColumnSchemaFormReducer'\nimport {\n  Box,\n  Button,\n  ButtonGroup,\n  Checkbox as MUICheckbox,\n  Typography,\n} from '@mui/material'\nimport { isEqual, times } from 'lodash-es'\nimport { selectAtom } from 'jotai/utils'\nimport ColumnModelForm from './ColumnModelForm'\nimport AddToList from '../../assets/icons/AddToList'\nimport { AddCircleTwoTone, North, South } from '@mui/icons-material'\nimport IconSvg from '../IconSvg'\n\nconst COLUMN_SCHEMA_FORM_GRID_TEMPLATE_COLUMNS =\n  '18px 18px 2fr 2fr 0.75fr 1fr 1fr 1fr 1fr'\nconst GRID_CONTAINER_Y_MARGIN_PX = 6\nexport const HIERARCHY_VERTICAL_LINE_COMPONENT = (\n  <Box\n    sx={{\n      width: '1px',\n      height: `calc(100% + 2 * ${GRID_CONTAINER_Y_MARGIN_PX}px)`,\n      backgroundColor: 'grey.400',\n      marginLeft: '8px',\n    }}\n  />\n)\nexport const HIERARCHY_END_COMPONENT = (\n  <Box\n    sx={theme => ({\n      width: '50%',\n      height: '60%',\n      borderLeft: `1px solid ${theme.palette.grey[400]}`,\n      borderBottom: `1px solid ${theme.palette.grey[400]}`,\n      marginLeft: '8px',\n      marginBottom: 'auto',\n      marginRight: '0',\n      borderBottomLeftRadius: '5px',\n    })}\n  />\n)\ntype TableColumnSchemaFormProps = {\n  /* The type of the Table, which determines various schema restrictions and form functionality */\n  entityType: EntityType\n  initialData?: ColumnModel[]\n}\n\nexport default function TableColumnSchemaForm(\n  props: TableColumnSchemaFormProps,\n) {\n  const { initialData, entityType } = props\n\n  const numColumnModels = useAtomValue(\n    useMemo(() => atom(get => get(tableColumnSchemaFormDataAtom).length), []),\n  )\n\n  const dispatch = useSetAtom(tableColumnSchemaFormDataAtom)\n\n  useEffect(() => {\n    if (initialData) {\n      dispatch({\n        type: 'setValue',\n        value: initialData.map(\n          (cm: ColumnModel): ColumnModelFormData => ({\n            ...cm,\n            jsonSubColumns: cm.jsonSubColumns?.map(\n              (jsc: JsonSubColumnModel): JsonSubColumnModelFormData => ({\n                ...jsc,\n                isSelected: false,\n              }),\n            ),\n            isSelected: false,\n          }),\n        ),\n      })\n    }\n    // Only run on mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  return (\n    <Box\n      sx={{\n        py: 2.5,\n        borderBottom: '2px solid',\n        borderColor: 'grey.300',\n      }}\n    >\n      <TableColumnSchemaFormActions />\n      <Box\n        display={'grid'}\n        sx={{\n          gridTemplateColumns: COLUMN_SCHEMA_FORM_GRID_TEMPLATE_COLUMNS,\n          py: 2.5,\n          fontWeight: 700,\n        }}\n        gap={'8px'}\n      >\n        <Box>{/* Checkbox */}</Box>\n        <Box sx={{ gridColumn: '2 / span 2' }}>Column Name</Box>\n        <Box>Column Type</Box>\n        <Box>Size</Box>\n        <Box>Max List Length</Box>\n        <Box>Default Value</Box>\n        <Box>Restrict Values</Box>\n        <Box>Facet</Box>\n        {times(numColumnModels, index => {\n          return (\n            <TableColumnSchemaFormRow\n              entityType={entityType}\n              columnModelIndex={index}\n              key={index}\n            />\n          )\n        })}\n      </Box>\n\n      <Button\n        variant={'outlined'}\n        onClick={() => {\n          dispatch({ type: 'appendColumn' })\n        }}\n        startIcon={<AddCircleTwoTone />}\n      >\n        Add Column\n      </Button>\n      {/*  Add / import buttons here  */}\n    </Box>\n  )\n}\n\nfunction TableColumnSchemaFormActions() {\n  const dispatch = useSetAtom(tableColumnSchemaFormDataAtom)\n\n  const columnModels = useAtomValue(tableColumnSchemaFormDataAtom)\n  const allSelected = getIsAllSelected(columnModels)\n  const numSelected = getNumberOfSelectedItems(columnModels)\n\n  return (\n    <Box display={'flex'} gap={1}>\n      <Button\n        variant={'outlined'}\n        color={'neutral'}\n        onClick={() => {\n          dispatch({ type: 'toggleSelectAll' })\n        }}\n      >\n        {/*\n           MUI Checkbox looks a little different from ours, but it has an indeterminate state\n           TODO: reconcile these differences\n          */}\n        <MUICheckbox\n          size={'small'}\n          checked={allSelected}\n          indeterminate={numSelected > 0 && !allSelected}\n        />\n        <Typography variant=\"smallText1\" color={'text.secondary'}>\n          {numSelected} selected\n        </Typography>\n      </Button>\n      <ButtonGroup>\n        <Button\n          aria-label={'Move Down'}\n          variant={'outlined'}\n          color={'neutral'}\n          onClick={() => {\n            dispatch({ type: 'moveDown' })\n          }}\n          disabled={numSelected == 0}\n        >\n          <South fontSize={'small'} />\n        </Button>\n        <Button\n          aria-label={'Move Up'}\n          variant={'outlined'}\n          color={'neutral'}\n          onClick={() => {\n            dispatch({ type: 'moveUp' })\n          }}\n          disabled={numSelected == 0}\n        >\n          <North fontSize={'small'} />\n        </Button>\n      </ButtonGroup>\n      <Button\n        aria-label={'Delete'}\n        variant={'outlined'}\n        color={'neutral'}\n        onClick={() => {\n          dispatch({ type: 'delete' })\n        }}\n        disabled={numSelected == 0}\n      >\n        <IconSvg fontSize={'small'} icon={'delete'} wrap={false} />\n      </Button>\n    </Box>\n  )\n}\n\ntype TableColumnSchemaFormRowProps = {\n  entityType: EntityType\n  columnModelIndex: number\n}\n\nfunction TableColumnSchemaFormRow(props: TableColumnSchemaFormRowProps) {\n  const { columnModelIndex, entityType } = props\n  const dispatch = useSetAtom(tableColumnSchemaFormDataAtom)\n  const columnModel = useAtomValue(\n    useMemo(\n      () =>\n        selectAtom(\n          tableColumnSchemaFormDataAtom,\n          v => v[columnModelIndex],\n          isEqual,\n        ),\n      [columnModelIndex],\n    ),\n  )\n\n  if (!columnModel) {\n    return <></>\n  }\n\n  return (\n    <>\n      <ColumnModelForm\n        entityType={entityType}\n        columnModelIndex={columnModelIndex}\n      />\n      {columnModel.columnType === ColumnTypeEnum.JSON &&\n        columnModel.jsonSubColumns &&\n        columnModel.jsonSubColumns.map((subColumnFacet, index) => (\n          <ColumnModelForm\n            key={index}\n            entityType={entityType}\n            columnModelIndex={columnModelIndex}\n            jsonSubColumnIndex={index}\n          />\n        ))}\n      {columnModel.columnType === ColumnTypeEnum.JSON && (\n        <>\n          <Box\n            sx={{\n              gridColumn: '1 / span 2',\n            }}\n          >\n            {HIERARCHY_END_COMPONENT}\n          </Box>\n          <Box>\n            <Button\n              startIcon={<AddToList />}\n              variant={'text'}\n              onClick={() =>\n                dispatch({ type: 'appendJsonSubColumn', columnModelIndex })\n              }\n            >\n              Add sub-column\n            </Button>\n          </Box>\n        </>\n      )}\n    </>\n  )\n}\n","import React from 'react'\nimport {\n  useGetEntity,\n  useGetQueryResultBundleWithAsyncStatus,\n} from '../../synapse-queries'\nimport { BUNDLE_MASK_QUERY_COLUMN_MODELS } from '../../utils/SynapseConstants'\nimport { useDeepCompareMemoize } from 'use-deep-compare-effect'\nimport { SkeletonTable } from '../Skeleton'\nimport { convertToEntityType } from '../../utils/functions/EntityTypeUtils'\nimport TableColumnSchemaForm from './TableColumnSchemaForm'\n\nexport type TableColumnSchemaEditorProps = {\n  entityId: string\n}\n\n/**\n * Fetches column model data for a Synapse Table and renders a form to edit the column models.\n * @param props\n * @constructor\n */\nexport default function TableColumnSchemaEditor(\n  props: TableColumnSchemaEditorProps,\n) {\n  const { entityId } = props\n\n  const { data: entity, isLoading: isLoadingEntity } = useGetEntity(entityId)\n  const { data: _queryResultBundle, isLoading: isLoadingColumnModels } =\n    useGetQueryResultBundleWithAsyncStatus(\n      {\n        entityId,\n        query: {\n          sql: 'SELECT * FROM ${entityId}',\n        },\n        partMask: BUNDLE_MASK_QUERY_COLUMN_MODELS,\n        concreteType: 'org.sagebionetworks.repo.model.table.QueryBundleRequest',\n      },\n      {\n        // This data is inserted into a form, so don't refetch it.\n        staleTime: Infinity,\n        useErrorBoundary: true,\n      },\n    )\n\n  const isLoading = isLoadingEntity || isLoadingColumnModels\n\n  // TODO: the hook above is not returning a stable reference. this is unexpected.\n  const queryResultBundle = useDeepCompareMemoize(_queryResultBundle)\n\n  if (isLoading || !entity) {\n    return (\n      <SkeletonTable\n        numRows={8}\n        numCols={7}\n        rowHeight={'50px'}\n        fullWidthCells\n      />\n    )\n  }\n  return (\n    <TableColumnSchemaForm\n      entityType={convertToEntityType(entity.concreteType)}\n      initialData={queryResultBundle?.responseBody?.columnModels}\n    />\n  )\n}\n"],"names":["North","createSvgIcon","_jsx","South","atomWithReducer","initialValue","reducer","anAtom","atom","get","set","action","getCached$2","c","m","k","cache1$4","memo3","create","dep1","dep2","dep3","cache2","cache3","selectAtom","selector","equalityFn","EMPTY","selectValue","value","prevSlice","slice","derivedAtom","prev","unsupportedTypesForViews","ColumnTypeEnum","getAllowedColumnTypes","isView","isJsonSubColumnFacet","columnType","getFacetTypeFriendlyName","facetType","getColumnTypeFriendlyName","type","canHaveSize","canHaveMaxListLength","configureFacetsForType","allowedFacetTypes","canHaveDefault","DEFAULT_STRING_SIZE","MAX_STRING_SIZE","getMaxSizeForType","canHaveRestrictedValues","getIsAllSelected","formData","cm","jsc","getNumberOfSelectedItems","acc","curr","getDefaultColumnModelFormData","getDefaultJsonSubColumnFormData","moveSelectedItemsUp","arr","predicate","newArr","item","index","temp","moveSelectedItemsDown","i","changeColumnModelType","prevState","columnModelIndex","jsonSubColumnModelIndex","newColumnType","newColumnModelValue","cloneDeep","toggleSelectAll","_a","setColumnModelValue","toggleSelect","deleteColumnModel","moveElementInArray","arrayToReorder","fromIndex","toIndex","newArray","elementToMove","moveColumnModel","from","to","tableColumnSchemaFormDataAtom","jsonSubColumnFieldSx","topLevelColumnModelFieldSx","ColumnModelForm","props","jsonSubColumnIndex","entityType","isJsonSubColumn","dispatch","useSetAtom","VIEW_CONCRETE_TYPE_VALUES","convertToConcreteEntityType","isShowingRestrictedValuesModal","setIsShowingRestrictedValuesModal","useState","columnModelAtom","useMemo","v","isEqual","columnModel","useAtomValue","allowedColumnTypes","fieldSx","jsxs","Fragment","jsx","Box","HIERARCHY_VERTICAL_LINE_COMPONENT","Checkbox","TextField","e","FormControl","Select","MenuItem","JSONArrayEditorModal","newValue","isEmpty","Tooltip","React","Link","InfoTwoTone","COLUMN_SCHEMA_FORM_GRID_TEMPLATE_COLUMNS","GRID_CONTAINER_Y_MARGIN_PX","HIERARCHY_END_COMPONENT","theme","TableColumnSchemaForm","initialData","numColumnModels","useEffect","TableColumnSchemaFormActions","times","TableColumnSchemaFormRow","Button","AddCircleTwoTone","columnModels","allSelected","numSelected","MUICheckbox","Typography","ButtonGroup","IconSvg","subColumnFacet","AddToList","TableColumnSchemaEditor","entityId","entity","isLoadingEntity","useGetEntity","_queryResultBundle","isLoadingColumnModels","useGetQueryResultBundleWithAsyncStatus","BUNDLE_MASK_QUERY_COLUMN_MODELS","isLoading","queryResultBundle","useDeepCompareMemoize","SkeletonTable","convertToEntityType"],"mappings":"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","x_google_ignoreList":[0,1,2]}