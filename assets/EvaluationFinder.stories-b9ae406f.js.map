{"version":3,"file":"EvaluationFinder.stories-b9ae406f.js","sources":["../../src/synapse-queries/evaluation/useEvaluation.ts","../../src/components/EvaluationFinder/EvaluationFinder.tsx"],"sourcesContent":["import {\n  Evaluation,\n  GetEvaluationParameters,\n  PaginatedResults,\n} from '@sage-bionetworks/synapse-types'\nimport { useInfiniteQuery, UseInfiniteQueryOptions } from 'react-query'\nimport { SynapseClientError, useSynapseContext } from '../../utils'\nimport SynapseClient from '../../synapse-client'\nimport { getNextPageParamForPaginatedResults } from '../InfiniteQueryUtils'\n\nexport function useGetEvaluationsInfinite(\n  request: GetEvaluationParameters = {},\n  options?: UseInfiniteQueryOptions<\n    PaginatedResults<Evaluation>,\n    SynapseClientError\n  >,\n) {\n  const LIMIT = 20\n  const { accessToken, keyFactory } = useSynapseContext()\n\n  return useInfiniteQuery<PaginatedResults<Evaluation>, SynapseClientError>(\n    keyFactory.getEvaluationsQueryKey(request),\n    async context =>\n      SynapseClient.getEvaluations(\n        { ...request, limit: LIMIT, offset: context.pageParam },\n        accessToken,\n      ),\n\n    {\n      ...options,\n      getNextPageParam: getNextPageParamForPaginatedResults,\n    },\n  )\n}\n","import React, { useState } from 'react'\nimport { useGetEvaluationsInfinite } from '../../synapse-queries/evaluation/useEvaluation'\nimport { HelpPopover } from '../HelpPopover/HelpPopover'\nimport {\n  Alert,\n  Box,\n  Button,\n  FormControl,\n  FormGroup,\n  LinearProgress,\n  Typography,\n} from '@mui/material'\nimport { GetEvaluationParameters } from '@sage-bionetworks/synapse-types'\nimport { Checkbox } from '../widgets/Checkbox'\n\nexport type EvaluationFinderProps = Pick<\n  GetEvaluationParameters,\n  'accessType' | 'activeOnly'\n> & {\n  selectedIds: string[]\n  onChange: (newSelectedIds: string[]) => void\n}\n\nexport default function EvaluationFinder(props: EvaluationFinderProps) {\n  const { accessType, activeOnly, selectedIds = [], onChange } = props\n  const [currentPage, setCurrentPage] = useState(0)\n  const {\n    data,\n    isLoading,\n    hasNextPage: hasNextPageOnServer,\n    fetchNextPage,\n    isFetchingNextPage,\n  } = useGetEvaluationsInfinite(\n    {\n      accessType,\n      activeOnly,\n    },\n    { keepPreviousData: true, useErrorBoundary: true },\n  )\n\n  if (isLoading) {\n    return <LinearProgress />\n  }\n  if (!data?.pages) {\n    // This should never happen since errors are propagated to the error boundary\n    return (\n      <Alert severity=\"error\">\n        An unexpected error occurred and evaluations could not be loaded\n      </Alert>\n    )\n  }\n\n  const hasNextPageInState = data.pages.length - 1 > currentPage\n  const canGoToNextPage =\n    hasNextPageInState || (hasNextPageOnServer && !isFetchingNextPage)\n\n  return (\n    <>\n      <FormControl>\n        <FormGroup sx={{ gap: 1 }}>\n          {data.pages[currentPage]?.results.map(evaluation => (\n            <Checkbox\n              key={evaluation.id}\n              label={\n                <Typography variant={'smallText1'} component={'span'}>\n                  {evaluation.name}{' '}\n                  {evaluation.submissionInstructionsMessage &&\n                    evaluation.submissionInstructionsMessage.length > 0 && (\n                      <HelpPopover\n                        markdownText={evaluation.submissionInstructionsMessage}\n                        placement={'right'}\n                      />\n                    )}\n                </Typography>\n              }\n              aria-label={evaluation.name!}\n              checked={selectedIds.includes(evaluation.id!)}\n              onChange={() => {\n                if (selectedIds.includes(evaluation.id!)) {\n                  onChange(selectedIds.filter(id => id !== evaluation.id))\n                } else {\n                  onChange([...selectedIds, evaluation.id!])\n                }\n              }}\n            />\n          ))}\n        </FormGroup>\n      </FormControl>\n      <Box display={'flex'} my={2} gap={1}>\n        {currentPage > 0 && (\n          <Button\n            variant={'outlined'}\n            onClick={() => setCurrentPage(page => page - 1)}\n          >\n            Previous\n          </Button>\n        )}\n        <Button\n          variant={'outlined'}\n          disabled={!canGoToNextPage}\n          onClick={() => {\n            if (data.pages[currentPage + 1]) {\n              setCurrentPage(page => page + 1)\n            } else {\n              fetchNextPage()\n                .then(() => setCurrentPage(page => page + 1))\n                .catch(() => {\n                  // The error will be thrown by the useGetEvaluationsInfinite hook handled by the error boundary\n                  console.error('Error fetching next page of evaluations')\n                })\n            }\n          }}\n        >\n          Next\n        </Button>\n      </Box>\n    </>\n  )\n}\n"],"names":["useGetEvaluationsInfinite","request","options","accessToken","keyFactory","useSynapseContext","useInfiniteQuery","context","SynapseClient","getNextPageParamForPaginatedResults","EvaluationFinder","props","accessType","activeOnly","selectedIds","onChange","currentPage","setCurrentPage","useState","data","isLoading","hasNextPageOnServer","fetchNextPage","isFetchingNextPage","jsx","LinearProgress","Alert","canGoToNextPage","jsxs","Fragment","FormControl","FormGroup","_a","evaluation","Checkbox","Typography","HelpPopover","id","Box","Button","page"],"mappings":"msNAUO,SAASA,EACdC,EAAmC,CAAC,EACpCC,EAIA,CAEA,KAAM,CAAE,YAAAC,EAAa,WAAAC,CAAW,EAAIC,EAAkB,EAE/C,OAAAC,EACLF,EAAW,uBAAuBH,CAAO,EACzC,MAAMM,GACJC,EAAc,eACZ,CAAE,GAAGP,EAAS,MAAO,GAAO,OAAQM,EAAQ,SAAU,EACtDJ,CACF,EAEF,CACE,GAAGD,EACH,iBAAkBO,CACpB,CAAA,CAEJ,CCVA,SAAAC,EAAAC,EAAA,OACE,KAAA,CAAA,WAAAC,EAAA,WAAAC,EAAA,YAAAC,EAAA,CAAA,EAAA,SAAAC,CAAA,EAAAJ,EACA,CAAAK,EAAAC,CAAA,EAAAC,EAAA,SAAA,CAAA,EACA,CAAM,KAAAC,EACJ,UAAAC,EACA,YAAAC,EACa,cAAAC,EACb,mBAAAC,CACA,EAAAvB,EACE,CACF,WAAAY,EACE,WAAAC,CACA,EACF,CAAA,iBAAA,GAAA,iBAAA,EAAA,CACiD,EAGnD,GAAAO,EACE,OAAAI,EAAAC,EAAA,CAAA,CAAA,EAEF,GAAA,EAAAN,GAAA,MAAAA,EAAA,OAEE,OAAAK,EAAAE,EAAA,CAAA,SAAA,QAAA,SAAA,kEAAA,CAAA,EAQF,MAAAC,EADAR,EAAA,MAAA,OAAA,EAAAH,GACAK,GAAA,CAAAE,EAGA,OAAAK,EAAAC,EAAA,CAAA,SAAA,CAEIL,EAAAM,EAAA,CAAA,SAAAN,EAAAO,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,EAAA,UAAAC,EAAAb,EAAA,MAAAH,CAAA,IAAA,YAAAgB,EAAA,QAAA,IAAAC,GAAAT,EAGMU,EAAC,CAAA,MAAAN,EAAAO,EAAA,CAAA,QAAA,aAAA,UAAA,OAAA,SAAA,CAIMF,EAAA,KAAW,IAAMA,EAAA,+BAAAA,EAAA,8BAAA,OAAA,GAAAT,EAGdY,EAAC,CAAA,aAAAH,EAAA,8BAC0B,UAAA,OACd,CAAA,CACb,EAAA,EAEN,aAAAA,EAAA,KAEqB,QAAAnB,EAAA,SAAAmB,EAAA,EAAA,EACqB,SAAA,IAAA,CAE1CnB,EAAA,SAAAmB,EAAA,EAAA,EACElB,EAAAD,EAAA,OAAAuB,GAAAA,IAAAJ,EAAA,EAAA,CAAA,EAEAlB,EAAA,CAAA,GAAAD,EAAAmB,EAAA,EAAA,CAAA,CACF,CACF,EAAAA,EAAA,EArBgB,EAAA,CAAA,CAAA,CAAA,EAyBxBL,EAAAU,EAAA,CAAA,QAAA,OAAA,GAAA,EAAA,IAAA,EAAA,SAAA,CAEGtB,EAAA,GAAAQ,EACCe,EAAC,CAAA,QAAA,WACU,QAAA,IAAAtB,EAAAuB,GAAAA,EAAA,CAAA,EACqC,SAAA,UAC/C,CAAA,EAEDhB,EAEFe,EAAC,CAAA,QAAA,WACU,SAAA,CAAAZ,EACE,QAAA,IAAA,CAETR,EAAA,MAAAH,EAAA,CAAA,EACEC,EAAAuB,GAAAA,EAAA,CAAA,EAEAlB,EAAA,EAAA,KAAA,IAAAL,EAAAuB,GAAAA,EAAA,CAAA,CAAA,EAAA,MAAA,IAAA,CAII,QAAA,MAAA,yCAAA,CAAuD,CAAA,CAE7D,EACF,SAAA,MACD,CAAA,CAED,EAAA,CACF,CAAA,CAAA,CAGN;;;"}